<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Sogrey</title>
  
  <subtitle>必须努力，付出不亚于任何人的努力</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://sogrey.github.io/"/>
  <updated>2021-02-26T12:28:43.905Z</updated>
  <id>https://sogrey.github.io/</id>
  
  <author>
    <name>Sogrey</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Promise.all和Promise.allSettled的区别</title>
    <link href="https://sogrey.github.io/article/Promise-all%E5%92%8CPromise-allSettled%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>https://sogrey.github.io/article/Promise-all和Promise-allSettled的区别/</id>
    <published>2021-02-24T15:33:53.000Z</published>
    <updated>2021-02-26T12:28:43.905Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>一句话概括Promise.allSettled和Promise.all的最大不同：<strong>Promise.allSettled永远不会被reject</strong>。</p><span id="more"></span><p>转自：<a href="https://segmentfault.com/a/1190000023413699">Promise.all和Promise.allSettled的区别</a></p><h2 id="解决Promise-all的痛点"><a href="#解决Promise-all的痛点" class="headerlink" title="解决Promise.all的痛点"></a>解决Promise.all的痛点</h2><p>当需要处理多个Promise并行时，大多数情况下Promise.all用起来是非常顺手的，比如下面这样</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> delay = <span class="function"><span class="params">n</span> =&gt;</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> <span class="built_in">setTimeout</span>(resolve, n));</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> promises = [</span><br><span class="line">  delay(<span class="number">100</span>).then(<span class="function">() =&gt;</span> <span class="number">1</span>),</span><br><span class="line">  delay(<span class="number">200</span>).then(<span class="function">() =&gt;</span> <span class="number">2</span>),</span><br><span class="line">  ]</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.all(promises).then(<span class="function"><span class="params">values</span>=&gt;</span><span class="built_in">console</span>.log(values))</span><br><span class="line"><span class="comment">// 最终输出： [1, 2]</span></span><br></pre></td></tr></table></figure><p>可是，是一旦有一个promise出现了异常，被reject了，情况就会变的麻烦。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promises = [</span><br><span class="line">  delay(<span class="number">100</span>).then(<span class="function">() =&gt;</span> <span class="number">1</span>),</span><br><span class="line">  delay(<span class="number">200</span>).then(<span class="function">() =&gt;</span> <span class="number">2</span>),</span><br><span class="line">  <span class="built_in">Promise</span>.reject(<span class="number">3</span>)</span><br><span class="line">  ]</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.all(promises).then(<span class="function"><span class="params">values</span>=&gt;</span><span class="built_in">console</span>.log(values))</span><br><span class="line"><span class="comment">// 最终输出： Uncaught (in promise) 3</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.all(promises)</span><br><span class="line">.then(<span class="function"><span class="params">values</span>=&gt;</span><span class="built_in">console</span>.log(values))</span><br><span class="line">.catch(<span class="function"><span class="params">err</span>=&gt;</span><span class="built_in">console</span>.log(err))</span><br><span class="line"><span class="comment">// 加入catch语句后，最终输出：3</span></span><br></pre></td></tr></table></figure><p>尽管能用catch捕获其中的异常，但你会发现其他执行成功的Promise的消息都丢失了，仿佛石沉大海一般。</p><p>要么全部成功，要么全部重来，这是Promise.all本身的强硬逻辑，也是痛点的来源，不能说它错，但这的确给Promise.allSettled留下了立足的空间。</p><p>假如使用Promise.allSettled来处理这段逻辑会怎样呢?</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promises = [</span><br><span class="line">  delay(<span class="number">100</span>).then(<span class="function">() =&gt;</span> <span class="number">1</span>),</span><br><span class="line">  delay(<span class="number">200</span>).then(<span class="function">() =&gt;</span> <span class="number">2</span>),</span><br><span class="line">  <span class="built_in">Promise</span>.reject(<span class="number">3</span>)</span><br><span class="line">  ]</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.allSettled(promises).then(<span class="function"><span class="params">values</span>=&gt;</span><span class="built_in">console</span>.log(values))</span><br><span class="line"><span class="comment">// 最终输出： </span></span><br><span class="line"><span class="comment">//    [</span></span><br><span class="line"><span class="comment">//      &#123;status: &quot;fulfilled&quot;, value: 1&#125;,</span></span><br><span class="line"><span class="comment">//      &#123;status: &quot;fulfilled&quot;, value: 2&#125;,</span></span><br><span class="line"><span class="comment">//      &#123;status: &quot;rejected&quot;, value: 3&#125;,</span></span><br><span class="line"><span class="comment">//    ]</span></span><br></pre></td></tr></table></figure><p>可以看到所有promise的数据都被包含在then语句中，且每个promise的返回值多了一个status字段，表示当前promise的状态，没有任何一个promise的信息被丢失。</p><p>因此，当用Promise.allSettled时，我们只需专注在then语句里，当有promise被异常打断时，我们依然能妥善处理那些已经成功了的promise，不必全部重来。</p><h2 id="当前大环境对Promise-allSettled的支持"><a href="#当前大环境对Promise-allSettled的支持" class="headerlink" title="当前大环境对Promise.allSettled的支持"></a>当前大环境对Promise.allSettled的支持</h2><p>nodejs从<a href="https://nodejs.org/en/blog/release/v12.9.0/">v12.9.0</a>开始加入了对Promise.allSettled的支持，主流浏览器们也各自在2019年发布的版本中支持了此方法，这意味着你已经可以放心大胆的使用了。</p><p><img src="https://image-static.segmentfault.com/292/869/2928695017-5f20c43ed364c_articlex" alt="promise-allsettled.png"></p><p><a href="https://caniuse.com/?search=Promise.allSettled">点此查询</a></p><p>对于那些不支持此方法的环境，你可以直接引用开源社区中实现了此方法的npm包：</p><ul><li><a href="https://www.npmjs.com/package/promise.allsettled">promise.allsettled</a></li><li><a href="https://www.npmjs.com/package/promise-settle">promise-settle</a></li><li><a href="https://www.npmjs.com/package/promise-all-settled">promise-all-settled</a></li><li><a href="https://www.npmjs.com/package/es2015-promise.allsettled">es2015-promise.allsettled</a></li></ul><p>或者，你可以直接基于Promise.all写一个polyfill，给你的项目打上补丁：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">Promise</span> &amp;&amp; !<span class="built_in">Promise</span>.allSettled) &#123;</span><br><span class="line">  <span class="built_in">Promise</span>.allSettled = <span class="function"><span class="keyword">function</span> (<span class="params">promises</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.all(promises.map(<span class="function"><span class="keyword">function</span> (<span class="params">promise</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> promise.then(<span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123; <span class="attr">state</span>: <span class="string">&#x27;fulfilled&#x27;</span>, <span class="attr">value</span>: value &#125;;</span><br><span class="line">      &#125;).catch(<span class="function"><span class="keyword">function</span> (<span class="params">reason</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123; <span class="attr">state</span>: <span class="string">&#x27;rejected&#x27;</span>, <span class="attr">reason</span>: reason &#125;;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;));</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>Promise.allSettled是对Promise.all的一种补充，当面对多个promise并行时，它额外提供了一种处理方式，解决了当多个promise并行时reject的出现会伴随着其他promise数据丢失的问题。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一句话概括Promise.allSettled和Promise.all的最大不同：&lt;strong&gt;Promise.allSettled永远不会被reject&lt;/strong&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="JS" scheme="https://sogrey.github.io/categories/JS/"/>
    
    
      <category term="JS" scheme="https://sogrey.github.io/tags/JS/"/>
    
      <category term="Promise" scheme="https://sogrey.github.io/tags/Promise/"/>
    
  </entry>
  
  <entry>
    <title>AutoCAD_ID、指针、句柄和ads_name的区别</title>
    <link href="https://sogrey.github.io/article/AutoCAD_ID__Handle__ads_name/"/>
    <id>https://sogrey.github.io/article/AutoCAD_ID__Handle__ads_name/</id>
    <published>2021-01-04T14:30:10.000Z</published>
    <updated>2021-01-05T12:37:36.707Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>转载自：<a href="https://my.oschina.net/u/2930533/blog/759617">https://my.oschina.net/u/2930533/blog/759617</a></p><p><img src="http://static.oschina.net/uploads/space/2016/1017/165317_6Tgq_2930533.png" alt=" "></p><span id="more"></span><p>访问实体的特性必须通过对象指针，但是一旦你获得了实体的ID、句柄或者ads_name，都能通过ID作中介而获得对象的指针。其中ID是一个桥梁。句柄是Windows编程一个常用的概念，在ObjectARX编程中一般指AcDbHandle类（也可指Windows编程的界面元素），该类封装了一个64位整形标识符，随DWG文件一同保存。ads_name则是在ADS编程中出现的一个概念，其实际上是一个二维数组，数组元素类型为长整型，在与用户交互的函数中经常用到。</p><h2 id="ID、句柄和-ads-name-具有各自的特点："><a href="#ID、句柄和-ads-name-具有各自的特点：" class="headerlink" title="ID、句柄和 ads_name 具有各自的特点："></a>ID、句柄和 ads_name 具有各自的特点：</h2><ol><li>AcDbObjectId：当dwg图形被打开后,数据库中的实体对象都会在内存中对应一个唯一的id(AcDbObjectId),AcDbObjectId也是与对象相关联的唯一标识符.AcDbObjectId仅存在于其所存在的数据库从内存中产生到数据库被删除之间.如果操作多个dwg,AcDbObjectId在多个数据库之间都是唯一的.</li><li>AcDbHandle：dwg文件中每一个实体都有一个唯一的标识符,用AcDbHandle表示,在一个AutoCAD中，不能保证每个实体的句柄都唯一。在autoCAD的两个Dwg中同一实体的句柄是相同的。实体的AcDbHandle可以随dwg文件被保存,所以即使dwg未被cad打开,也可以根据句柄搜索dwg文件获取对象信息.</li><li>AcDbObject对象指针:当一个对象被打开后,AutoCAD会返回指向AcDbObject或其派生类型的应该c++指针,然后就可以采用标准c++类对象的方式对实体进行操作.</li><li>ads_name：AutoCAd定义的一个数据类型.一般用来保存用户交互过程中成功选择实体的节点,ads_name是不稳定的，仅当你在一旦退出 AutoCAD 或者切换到另一个图形，ads_name 就会丢失.</li></ol><h2 id="ID、指针、句柄和-ads-name-之间具有下面的转换关系："><a href="#ID、指针、句柄和-ads-name-之间具有下面的转换关系：" class="headerlink" title="ID、指针、句柄和 ads_name 之间具有下面的转换关系："></a>ID、指针、句柄和 ads_name 之间具有下面的转换关系：</h2><ol><li>从 AcDbObjectId 到AcDbObject对象:acdbOpenAcDbObject() 或者 acdbOpenObject() 。</li><li>从 AcDbObject 对象到 AcDbObjectId ：所有的数据库常驻对象都继承自 AcDbObjectId 函数能获得所指向对象的 ID。</li><li>从AcDbHandle 到 AcDbObjectId ： AcDbDatabase::getAcDbObjectId();</li><li>从 AcDbObjectId 到AcDbHandle ：AcDbObjectId::handle() 。</li><li>从 AcDbObject 到AcDbHandle ：AcDbObject::getAcDbHandle().</li><li>从 ads_name 到 AcDbObjectId ：使用全局函数 acdbGetObjectId()。</li><li>从 AcDbObjectId 到 ads_name ：使用全局函数 acdbGetAdsName()。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;转载自：&lt;a href=&quot;https://my.oschina.net/u/2930533/blog/759617&quot;&gt;https://my.oschina.net/u/2930533/blog/759617&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://static.oschina.net/uploads/space/2016/1017/165317_6Tgq_2930533.png&quot; alt=&quot; &quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="AutoCad" scheme="https://sogrey.github.io/categories/AutoCad/"/>
    
    
      <category term="Cad" scheme="https://sogrey.github.io/tags/Cad/"/>
    
  </entry>
  
  <entry>
    <title>致敬2020，重启2021</title>
    <link href="https://sogrey.github.io/article/2020-2021/"/>
    <id>https://sogrey.github.io/article/2020-2021/</id>
    <published>2020-12-30T16:45:50.000Z</published>
    <updated>2021-01-25T15:43:26.615Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><ul><li><a href="https://sogrey.top/article/%E5%86%8D%E8%A7%812018%EF%BC%8C%E4%BD%A0%E5%A5%BD2019/">再见2018，你好2019</a></li><li><a href="https://sogrey.top/article/zj2019-zw2020/">总结2019，展望2020</a></li></ul><hr><p>今年注定将是不平凡的一年，自年初，噩耗传来，一场疫情打破了我们所有人的生活，眼看年底将至，我们依旧还能听闻有关疫情的讯息。这一年，国人展现出无比团结，一城遭苦难，举国来驰援。最艰难的时刻已经渡过，2021已然在路上。</p><span id="more"></span><h2 id="工作上"><a href="#工作上" class="headerlink" title="工作上"></a>工作上</h2><p>比起去年，今年的工作总结就简单太多了，自2月开始，加入到公司CAD引擎组，到年底几乎全年主要的任务中心就放在了引擎开发上。截止目前引擎已经历了三次大的版本更新，从最早的单图元mesh，到现在应用分层分块实例化应运，对于图纸加载素对有了很大提升，支持更大图纸。直到现在，我们又到了一个瓶颈期，需要支持更大图纸、更少的数据交互以及更快的渲染速度，这次将是个更大的挑战，我们开始考虑重新定义数据结构已优化数据传输速度，这项工作已经在进行中了。</p><p>由于一些工作上的需求，最近也参与修改和完善了一些Java的项目，我本Android出身，Java略懂皮毛，参与修改 Java Springboot 项目，开始是没什么信心的，但接触了下也得到了同事的指导，也就慢慢上手了。重新接触Java，成功上手并未接触过的Springboot觉得还是蛮有成就感。</p><h2 id="个人提升"><a href="#个人提升" class="headerlink" title="个人提升"></a>个人提升</h2><p>今年由于受到疫情影响、工作内容也很充实，也就无暇太多的顾及其他方面的知识和技能。要说的其他方面的知识与技能也是有的：</p><ol><li>华为鸿蒙（HarmonyOS）开源，自己也上手写过很简单的demo，追过华为开发者联盟推出的共14期的公开课程，对于分布式系统也算是有所了解。</li><li>参与Java Springboot项目，发现这是个很好用的框架，为此我查过很多资料，虽然大多是工作需求驱使，但在此过程中也学到很多，也是个不错的方向。</li><li>由于Java项目要同时运行在Windows和Linux两个平台上，Linux接触并不多，为了测试项目成果，也查阅了不少Linux知识、命令，也算是有收获的。</li><li>可能也是受其他博主影响，这一年也尽量的每天学习和记录有关前端、Android开发等方面知识并记录，有的可能是实际应用终于到的问题或者在查阅资料时看到比较好的经验总结，也算是站在很多个巨人的肩上眺望远方。</li></ol><h2 id="生活上"><a href="#生活上" class="headerlink" title="生活上"></a>生活上</h2><p>亲爱的宝贝闺女终于上幼儿园了，虽然受疫情影响，晚上一学期。每天从微信群中看到老师发布的幼儿动态，宝贝状态比我预期的要好不少，不哭不闹。希望两个宝贝都能健康成长、快快乐乐。</p><h2 id="未来期许"><a href="#未来期许" class="headerlink" title="未来期许"></a>未来期许</h2><p>对于将来的期许，眼下，还是以目前手里的工作为主，CAD引擎到了瓶颈期，需要一次跨越，我们将为此努力。除此外还有:</p><ol><li>去年提到要考学驾照，今年得空去考了科一，但后续由于工作原因（其实是因为懒）没有继续练车再考，2021年完成剩余的科目。</li><li>坚持每日学习和记录至少一项知识点</li><li>鸿蒙的开源也让我试着成为一个鸿蒙开发者，毕竟有Android的开发经验，这样的过渡应该不难。</li><li>继续学习一些其他的编程语言，像Typescript、Es6+、Flutter等</li><li>…</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://sogrey.top/article/%E5%86%8D%E8%A7%812018%EF%BC%8C%E4%BD%A0%E5%A5%BD2019/&quot;&gt;再见2018，你好2019&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://sogrey.top/article/zj2019-zw2020/&quot;&gt;总结2019，展望2020&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;p&gt;今年注定将是不平凡的一年，自年初，噩耗传来，一场疫情打破了我们所有人的生活，眼看年底将至，我们依旧还能听闻有关疫情的讯息。这一年，国人展现出无比团结，一城遭苦难，举国来驰援。最艰难的时刻已经渡过，2021已然在路上。&lt;/p&gt;
    
    </summary>
    
      <category term="年终总结" scheme="https://sogrey.github.io/categories/%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="年终总结" scheme="https://sogrey.github.io/tags/%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>java调用shell脚本</title>
    <link href="https://sogrey.github.io/article/java%E8%B0%83%E7%94%A8shell%E8%84%9A%E6%9C%AC/"/>
    <id>https://sogrey.github.io/article/java调用shell脚本/</id>
    <published>2020-12-28T09:12:48.000Z</published>
    <updated>2020-12-27T15:43:13.016Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>需要bash环境下执行，Windows推荐安装Git For Windows（<a href="https://github.com/waylau/git-for-win">国内下载站</a>），Linux下默认就是bash。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">String systemType = <span class="string">&quot;linux&quot;</span>;<span class="comment">//区分Linux和Windows</span></span><br><span class="line">String tifShPath = <span class="string">&quot;F:/test.sh&quot;</span>;<span class="comment">// shell脚本</span></span><br><span class="line">String cmd = <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (systemType.equalsIgnoreCase(<span class="string">&quot;linux&quot;</span>)) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Runtime.getRuntime().exec(<span class="string">&quot;chmod 755 -R &quot;</span> + tifShPath);<span class="comment">//获取可读可执行权限</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">cmd = tifShPath;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;<span class="comment">// windows</span></span><br><span class="line">cmd = <span class="string">&quot;bash &quot;</span> + tifShPath;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Process child = Runtime.getRuntime().exec(cmd);</span><br><span class="line">InputStream in = child.getInputStream();</span><br><span class="line">BufferedReader bufferedReader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(in));</span><br><span class="line">String line;</span><br><span class="line"><span class="keyword">while</span> ((line = bufferedReader.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">System.out.println(line);</span><br><span class="line">&#125;</span><br><span class="line">in.close();</span><br><span class="line">child.waitFor();</span><br><span class="line"><span class="keyword">if</span> (bufferedReader != <span class="keyword">null</span>) &#123;</span><br><span class="line">bufferedReader.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">System.out.println(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><span id="more"></span><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://blog.csdn.net/sayoko06/article/details/88797838">java调用shell脚本及注意事项</a></li><li><a href="https://blog.csdn.net/qq_39477018/article/details/88849003">java调用shell文件、远程调用shell文件并且传入参数、.sh文件执行的几种方法</a></li><li><a href="https://blog.csdn.net/dream_broken/article/details/54289008">java调用shell脚本并传递参数</a></li><li><a href="https://www.yuque.com/docs/share/86e3fa77-39f5-4362-b809-a3c161370bcc">【大数据】Shell任务在Java中的执行</a></li><li><a href="https://www.jianshu.com/p/10f4771909f9">使用ProcessBuilder执行命令行操作</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;需要bash环境下执行，Windows推荐安装Git For Windows（&lt;a href=&quot;https://github.com/waylau/git-for-win&quot;&gt;国内下载站&lt;/a&gt;），Linux下默认就是bash。&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;String systemType = &lt;span class=&quot;string&quot;&gt;&amp;quot;linux&amp;quot;&lt;/span&gt;;&lt;span class=&quot;comment&quot;&gt;//区分Linux和Windows&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;String tifShPath = &lt;span class=&quot;string&quot;&gt;&amp;quot;F:/test.sh&amp;quot;&lt;/span&gt;;&lt;span class=&quot;comment&quot;&gt;// shell脚本&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;String cmd = &lt;span class=&quot;string&quot;&gt;&amp;quot;&amp;quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (systemType.equalsIgnoreCase(&lt;span class=&quot;string&quot;&gt;&amp;quot;linux&amp;quot;&lt;/span&gt;)) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;try&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		Runtime.getRuntime().exec(&lt;span class=&quot;string&quot;&gt;&amp;quot;chmod 755 -R &amp;quot;&lt;/span&gt; + tifShPath);&lt;span class=&quot;comment&quot;&gt;//获取可读可执行权限&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125; &lt;span class=&quot;keyword&quot;&gt;catch&lt;/span&gt; (IOException e) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		e.printStackTrace();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	cmd = tifShPath;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;span class=&quot;comment&quot;&gt;// windows&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	cmd = &lt;span class=&quot;string&quot;&gt;&amp;quot;bash &amp;quot;&lt;/span&gt; + tifShPath;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;try&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	Process child = Runtime.getRuntime().exec(cmd);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	InputStream in = child.getInputStream();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	BufferedReader bufferedReader = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; BufferedReader(&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; InputStreamReader(in));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	String line;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; ((line = bufferedReader.readLine()) != &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		System.out.println(line);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	in.close();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	child.waitFor();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (bufferedReader != &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		bufferedReader.close();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125; &lt;span class=&quot;keyword&quot;&gt;catch&lt;/span&gt; (Exception e) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	System.out.println(e);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Java" scheme="https://sogrey.github.io/categories/Java/"/>
    
    
      <category term="Java" scheme="https://sogrey.github.io/tags/Java/"/>
    
      <category term="shell" scheme="https://sogrey.github.io/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot 项目瘦身</title>
    <link href="https://sogrey.github.io/article/SpringBoot%E9%A1%B9%E7%9B%AE%E7%98%A6%E8%BA%AB/"/>
    <id>https://sogrey.github.io/article/SpringBoot项目瘦身/</id>
    <published>2020-12-26T15:22:55.000Z</published>
    <updated>2020-12-27T12:29:20.468Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>我们发现Spring Boot用起来非常方便，但是即使新建的空项目打包jar之后也要14M大小，将jar包解压发现<code>BOOT-INF/lib</code>大小就占到13.6M.我们对Springboot打包jar瘦身就是从包内将 <code>lib</code> 分离出来，因为对于项目而言架构确定后，引入的三方jar包基本就不会变动了；要是有新增库那就将新增的三方库分离出来就好啦。</p><span id="more"></span><p><img src="https://gitee.com/Sogrey/gitee-cdn/raw/master/imgs/Springboot-lib-size.png" alt=""></p><h2 id="分离出lib依赖三方库"><a href="#分离出lib依赖三方库" class="headerlink" title="分离出lib依赖三方库"></a>分离出lib依赖三方库</h2><p>pom.xml文件的build节点 可能是如下：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">source</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mainClass</span>&gt;</span>top.sogrey.HelloApplication<span class="tag">&lt;/<span class="name">mainClass</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">layout</span>&gt;</span>ZIP<span class="tag">&lt;/<span class="name">layout</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><br>分离前我们需要通过常用的打包命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Maven ckean</span><br><span class="line">Maven install</span><br></pre></td></tr></table></figure><br>从<code>target</code>目录下拿到完整的jar包（14M）,解压，将<code>BOOT-INF/lib</code>另存。</p><h2 id="修改pom-xml配置，编译出不带-lib-文件夹的Jar包"><a href="#修改pom-xml配置，编译出不带-lib-文件夹的Jar包" class="headerlink" title="修改pom.xml配置，编译出不带 lib 文件夹的Jar包"></a>修改pom.xml配置，编译出不带 lib 文件夹的Jar包</h2><p>修改后的pom.xml文件的build节点:<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">source</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mainClass</span>&gt;</span>top.sogrey.HelloApplication<span class="tag">&lt;/<span class="name">mainClass</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">layout</span>&gt;</span>ZIP<span class="tag">&lt;/<span class="name">layout</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">include</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>nothing<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>nothing<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><br>再次执行打包命令得到不带lib的jar包，大小才98k.</p><p><img src="https://gitee.com/Sogrey/gitee-cdn/raw/master/imgs/Springboot-lib-size2.png" alt=""></p><p>这时将之前分离出来的lib目录与不含lib的jar放在同一目录下,最终目录结构如下：</p><p>最终目录文件结构是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">├── lib   #lib文件夹  </span><br><span class="line">|  ├─ classmate-1.3.3.jar</span><br><span class="line">|  └─ ... # 其他jar包</span><br><span class="line">└── SpringBootDemo-0.0.1-SNAPSHOT.jar</span><br></pre></td></tr></table></figure></p><p>执行命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ java -Dloader.path=lib -jar SpringBootDemo-0.0.1-SNAPSHOT.jar</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/Sogrey/gitee-cdn/raw/master/imgs/Springboot-lib-size3.png" alt=""></p><p>完整的jar包启动命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ java -jar SpringBootDemo-0.0.1-SNAPSHOT-FULL.jar</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://mp.weixin.qq.com/s/9CuGyrF5EGigxFmOhZtC4g">Spring Boot 项目瘦身指南，瘦到不可思议！</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们发现Spring Boot用起来非常方便，但是即使新建的空项目打包jar之后也要14M大小，将jar包解压发现&lt;code&gt;BOOT-INF/lib&lt;/code&gt;大小就占到13.6M.我们对Springboot打包jar瘦身就是从包内将 &lt;code&gt;lib&lt;/code&gt; 分离出来，因为对于项目而言架构确定后，引入的三方jar包基本就不会变动了；要是有新增库那就将新增的三方库分离出来就好啦。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="https://sogrey.github.io/categories/Java/"/>
    
    
      <category term="Java" scheme="https://sogrey.github.io/tags/Java/"/>
    
      <category term="Spring boot" scheme="https://sogrey.github.io/tags/Spring-boot/"/>
    
  </entry>
  
  <entry>
    <title>Springboot跨域请求</title>
    <link href="https://sogrey.github.io/article/Springboot%E8%B7%A8%E5%9F%9F%E8%AF%B7%E6%B1%82/"/>
    <id>https://sogrey.github.io/article/Springboot跨域请求/</id>
    <published>2020-12-26T14:18:03.000Z</published>
    <updated>2020-12-26T15:23:43.408Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Spring Boot部署起来可以很简单，但是只要部署在网络就存在跨域问题，Springboot添加跨域请求的处理也有好几种方法。</p><span id="more"></span><h2 id="增加注解-CrossOrigin"><a href="#增加注解-CrossOrigin" class="headerlink" title="增加注解@CrossOrigin"></a>增加注解@CrossOrigin</h2><p>在需要跨域的类或方法上方增加注解<code>@CrossOrigin</code>，只针对单个方法或类有效，适用于只有个别方法需要跨域的情况。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span> <span class="comment">// 标明这是一个SpringMVC的Controller控制器</span></span><br><span class="line"><span class="meta">@CrossOrigin</span></span><br><span class="line"><span class="meta">@RequestMapping(value = &quot;/api&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> Environment env;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="meta">@CrossOrigin</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="支持跨域请求的-Configuration"><a href="#支持跨域请求的-Configuration" class="headerlink" title="支持跨域请求的 Configuration"></a>支持跨域请求的 Configuration</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.CorsRegistry;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.WebMvcConfigurerAdapter;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 处理AJAX请求跨域的问题</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CorsConfig</span> <span class="keyword">extends</span> <span class="title">WebMvcConfigurerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String ORIGINS[] = <span class="keyword">new</span> String[] &#123; <span class="string">&quot;GET&quot;</span>, <span class="string">&quot;POST&quot;</span>, <span class="string">&quot;PUT&quot;</span>, <span class="string">&quot;DELETE&quot;</span> &#125;;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addCorsMappings</span><span class="params">(CorsRegistry registry)</span> </span>&#123;</span><br><span class="line">        registry.addMapping(<span class="string">&quot;/**&quot;</span>).allowedOrigins(<span class="string">&quot;*&quot;</span>).allowCredentials(<span class="keyword">true</span>).allowedMethods(ORIGINS)</span><br><span class="line">                .maxAge(<span class="number">3600</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="跨域过滤器"><a href="#跨域过滤器" class="headerlink" title="跨域过滤器"></a>跨域过滤器</h2><p>此法亲测可用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@ComponentScan</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ManagementApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(ManagementApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> CorsConfiguration <span class="title">buildConfig</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        CorsConfiguration corsConfiguration = <span class="keyword">new</span> CorsConfiguration();</span><br><span class="line">        corsConfiguration.addAllowedOrigin(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">        corsConfiguration.addAllowedHeader(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">        corsConfiguration.addAllowedMethod(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> corsConfiguration;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 跨域过滤器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CorsFilter <span class="title">corsFilter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        UrlBasedCorsConfigurationSource source = <span class="keyword">new</span> UrlBasedCorsConfigurationSource();</span><br><span class="line">        source.registerCorsConfiguration(<span class="string">&quot;/**&quot;</span>, buildConfig()); </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CorsFilter(source);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以单独出来一个加注解<code>@Configuration</code>的类：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;  </span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;  </span><br><span class="line"><span class="keyword">import</span> org.springframework.web.cors.CorsConfiguration;  </span><br><span class="line"><span class="keyword">import</span> org.springframework.web.cors.UrlBasedCorsConfigurationSource;  </span><br><span class="line"><span class="keyword">import</span> org.springframework.web.filter.CorsFilter;  </span><br><span class="line">  </span><br><span class="line"><span class="meta">@Configuration</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CorsConfig</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> CorsConfiguration <span class="title">buildConfig</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        CorsConfiguration corsConfiguration = <span class="keyword">new</span> CorsConfiguration();  </span><br><span class="line">        corsConfiguration.addAllowedOrigin(<span class="string">&quot;*&quot;</span>); <span class="comment">// 1  </span></span><br><span class="line">        corsConfiguration.addAllowedHeader(<span class="string">&quot;*&quot;</span>); <span class="comment">// 2  </span></span><br><span class="line">        corsConfiguration.addAllowedMethod(<span class="string">&quot;*&quot;</span>); <span class="comment">// 3  </span></span><br><span class="line">        <span class="keyword">return</span> corsConfiguration;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Bean</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> CorsFilter <span class="title">corsFilter</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        UrlBasedCorsConfigurationSource source = <span class="keyword">new</span> UrlBasedCorsConfigurationSource();  </span><br><span class="line">        source.registerCorsConfiguration(<span class="string">&quot;/**&quot;</span>, buildConfig()); <span class="comment">// 4  </span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CorsFilter(source);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="Filter过滤器"><a href="#Filter过滤器" class="headerlink" title="Filter过滤器"></a>Filter过滤器</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.Filter;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.FilterChain;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.FilterConfig;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletResponse;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 处理跨域问题</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OriginFilter</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(FilterConfig filterConfig)</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest req, ServletResponse res,</span></span></span><br><span class="line"><span class="function"><span class="params">            FilterChain chain)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">        HttpServletResponse response = (HttpServletResponse) res;</span><br><span class="line">        response.setHeader(<span class="string">&quot;Access-Control-Allow-Origin&quot;</span>, <span class="string">&quot;*&quot;</span>);</span><br><span class="line">        response.setHeader(<span class="string">&quot;Access-Control-Allow-Methods&quot;</span>, <span class="string">&quot;POST, GET, OPTIONS, DELETE,PUT&quot;</span>);</span><br><span class="line">        response.setHeader(<span class="string">&quot;Access-Control-Max-Age&quot;</span>, <span class="string">&quot;3600&quot;</span>);</span><br><span class="line">        response.setHeader(<span class="string">&quot;Access-Control-Allow-Headers&quot;</span>, <span class="string">&quot;x-requested-with&quot;</span>);</span><br><span class="line">        chain.doFilter(req, res);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://my.oschina.net/u/2351298/blog/1813710">Springboot 处理跨域请求</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Spring Boot部署起来可以很简单，但是只要部署在网络就存在跨域问题，Springboot添加跨域请求的处理也有好几种方法。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="https://sogrey.github.io/categories/Java/"/>
    
    
      <category term="Java" scheme="https://sogrey.github.io/tags/Java/"/>
    
      <category term="Spring boot" scheme="https://sogrey.github.io/tags/Spring-boot/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot支持HTTPS</title>
    <link href="https://sogrey.github.io/article/SpringBoot%E6%94%AF%E6%8C%81HTTPS/"/>
    <id>https://sogrey.github.io/article/SpringBoot支持HTTPS/</id>
    <published>2020-12-16T16:01:15.000Z</published>
    <updated>2020-12-26T16:02:40.448Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>这里讲的是 Spring Boot 内嵌式 Server 打 jar 包运行的方式，打 WAR 包部署的就不存在要 Spring Boot 支持 HTTPS 了，只需去外部对应的 Server 配置。<br><span id="more"></span></p><h2 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h2><p><code>HTTPS</code> （全称：Hyper Text Transfer Protocol over SecureSocket Layer），是以安全为目标的 HTTP 通道，在HTTP的基础上通过传输加密和身份认证保证了传输过程的安全性。HTTPS 在HTTP 的基础下加入<a href="https://baike.baidu.com/item/SSL/320778">SSL</a> 层，HTTPS 的安全基础是 SSL，因此加密的详细内容就需要 SSL。 HTTPS 存在不同于 HTTP 的默认端口及一个加密/身份验证层（在 HTTP与 <a href="https://baike.baidu.com/item/TCP/33012">TCP</a> 之间）。这个系统提供了身份验证与加密通讯方法。它被广泛用于万维网上安全敏感的通讯，例如交易支付等方面。</p><h2 id="SpringBoot支持Https"><a href="#SpringBoot支持Https" class="headerlink" title="SpringBoot支持Https"></a>SpringBoot支持Https</h2><h3 id="第一步：获取证书"><a href="#第一步：获取证书" class="headerlink" title="第一步：获取证书"></a>第一步：获取证书</h3><p>要获取一个https证书，本地我们可以借助 Java 自带的 JDK 管理工具 keytool 来生成一个免费的 https 证书，也可以到腾讯云免费申请一个。</p><p>使用JDK生成，首先需要安装JDK，配置好java环境变量。</p><p><code>cmd</code>进入命令行输入<code>keytool</code>回车有输出不报错就行。</p><p>执行命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">keytool -genkey -<span class="built_in">alias</span> spring -keypass 123456 -storetype PKCS12 -keyalg RSA -keysize 2048 -validity 365 -keystore E:/spring.keystore -storepass 654321</span><br></pre></td></tr></table></figure></p><blockquote><p>E:/spring.keystore  -&gt; E:/spring.p12 ??</p></blockquote><p>其中几个参数的解释如下：</p><ol><li><code>-alias</code> 指定别名</li><li><code>-keypass</code>此别名对应密码</li><li><code>-storetype</code> 指定密钥仓库类型</li><li><code>-keyalg</code> 生证书的算法名称，RSA是一种非对称加密算法</li><li><code>-keysize</code> 证书大小</li><li><code>-keystore</code> 生成的证书文件的存储路径</li><li><code>-validity</code> 证书的有效期</li></ol><p>依次填写证书相关的信息:</p><p><img src="https://gitee.com/Sogrey/gitee-cdn/raw/master/imgs/keytool生成ssl证书.png" alt="keytool生成ssl证书"></p><p>在E盘下就生成一个文件<code>spring.keystore</code>。</p><h3 id="第二步：springboot项目中引入https"><a href="#第二步：springboot项目中引入https" class="headerlink" title="第二步：springboot项目中引入https"></a>第二步：springboot项目中引入https</h3><p>将刚刚生成的证书文件拷贝到项目中的<code>resources</code>目录中，修改<code>application.properties</code>文件，添加<code>HTTPS</code>支持。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">server.ssl.key-store&#x3D;spring.keystore</span><br><span class="line">server.ssl.key-store-password&#x3D;654321</span><br><span class="line">server.ssl.keyStoreType&#x3D;PKCS12</span><br><span class="line">server.ssl.keyAlias:spring</span><br></pre></td></tr></table></figure><p>配置完成后就启动可以启动项目了。</p><p>部署完成后使用工具：<a href="https://infinisign.com/tools/sslcheck/?lang=cn">SSL证书验证,SSL检测安装工具</a> 来检查SSL是否部署成功。</p><h2 id="配置好Https兼容http"><a href="#配置好Https兼容http" class="headerlink" title="配置好Https兼容http"></a>配置好Https兼容http</h2><p>配置好Https发现http就不好用了，此时访问http地址是不成功的，如果需要支持支持HTTP重定向到HTTPS，需要在配置类中配置一个<code>TomcatEmbeddedServletContainerFactory</code> bean:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> EmbeddedServletContainerFactory <span class="title">servletContainer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  TomcatEmbeddedServletContainerFactory tomcat = <span class="keyword">new</span> TomcatEmbeddedServletContainerFactory() &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">postProcessContext</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        SecurityConstraint securityConstraint = <span class="keyword">new</span> SecurityConstraint();</span><br><span class="line">        securityConstraint.setUserConstraint(<span class="string">&quot;CONFIDENTIAL&quot;</span>);</span><br><span class="line">        SecurityCollection collection = <span class="keyword">new</span> SecurityCollection();</span><br><span class="line">        collection.addPattern(<span class="string">&quot;/*&quot;</span>);</span><br><span class="line">        securityConstraint.addCollection(collection);</span><br><span class="line">        context.addConstraint(securityConstraint);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  tomcat.addAdditionalTomcatConnectors(initiateHttpConnector());</span><br><span class="line">  <span class="keyword">return</span> tomcat;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Connector <span class="title">initiateHttpConnector</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Connector connector = <span class="keyword">new</span> Connector(<span class="string">&quot;org.apache.coyote.http11.Http11NioProtocol&quot;</span>);</span><br><span class="line">  connector.setScheme(<span class="string">&quot;http&quot;</span>);</span><br><span class="line">  connector.setPort(<span class="number">8081</span>);</span><br><span class="line">  connector.setSecure(<span class="keyword">false</span>);</span><br><span class="line">  connector.setRedirectPort(<span class="number">8080</span>);</span><br><span class="line">  <span class="keyword">return</span> connector;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时访问<a href="http://localhost:8081">http://localhost:8081</a> 会自动跳转到<a href="https://localhost:8080">https://localhost:8080</a>  表明配置成功。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://blog.csdn.net/u013322876/article/details/95594859">Spring Boot 支持 HTTPS 如此简单，So easy!</a></li><li><a href="https://zhuanlan.zhihu.com/p/31385073">Spring Boot 使用SSL-HTTPS</a></li><li><a href="https://www.cnblogs.com/huanzi-qch/p/12133872.html">SpringBoot系列——启用https</a></li><li><a href="https://www.jianshu.com/p/8d4aba3b972d">SpringBoot配置HTTPS,并实现HTTP访问自动转HTTPS访问</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这里讲的是 Spring Boot 内嵌式 Server 打 jar 包运行的方式，打 WAR 包部署的就不存在要 Spring Boot 支持 HTTPS 了，只需去外部对应的 Server 配置。&lt;br&gt;
    
    </summary>
    
      <category term="Java" scheme="https://sogrey.github.io/categories/Java/"/>
    
    
      <category term="Java" scheme="https://sogrey.github.io/tags/Java/"/>
    
      <category term="Spring boot" scheme="https://sogrey.github.io/tags/Spring-boot/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot实现定时任务</title>
    <link href="https://sogrey.github.io/article/SpringBoot%E5%AE%9E%E7%8E%B0%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/"/>
    <id>https://sogrey.github.io/article/SpringBoot实现定时任务/</id>
    <published>2020-12-15T04:07:28.000Z</published>
    <updated>2020-12-25T16:39:03.323Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Spring 3.0 版本之后自带定时任务，提供了@EnableScheduling注解和@Scheduled注解来实现定时任务功能。</p><p>使用SpringBoot创建定时任务非常简单，目前主要有以下三种创建方式：</p><ol><li>基于注解（@Scheduled）</li><li>基于接口（SchedulingConfigurer） 前者相信大家都很熟悉，但是实际使用中我们往往想从数据库中读取指定时间来动态执行定时任务，这时候基于接口的定时任务就派上用场了。</li><li>基于注解设定多线程定时任务</li></ol><span id="more"></span><h2 id="基于注解（-Scheduled）"><a href="#基于注解（-Scheduled）" class="headerlink" title="基于注解（@Scheduled）"></a>基于注解（@Scheduled）</h2><h3 id="Scheduled注解和-EnableScheduling注解的使用"><a href="#Scheduled注解和-EnableScheduling注解的使用" class="headerlink" title="@Scheduled注解和@EnableScheduling注解的使用"></a>@Scheduled注解和@EnableScheduling注解的使用</h3><p>基于注解@Scheduled默认为单线程，开启多个任务时，任务的执行时机会受上一个任务执行时间的影响。</p><ul><li><code>@EnableScheduling</code>注解： 在配置类上使用，开启计划任务的支持（类上）。</li><li><code>@Scheduled</code>注解： 来声明这是一个任务，包括 <code>cron</code>，<code>fixDelay</code>，<code>fixRate</code> 等类型（方法上，需先开启计划任务的支持）。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.scheduling.annotation.EnableScheduling;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableScheduling</span> <span class="comment">// 开启定时任务</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 程序主入口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">SpringApplication.run(App.class, args);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个简单的定时任务，每5秒执行一次：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.scheduling.annotation.Scheduled;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ScheduleTask</span> </span>&#123;</span><br><span class="line"><span class="meta">@Scheduled(cron=&quot;0/5 * *  * * ? &quot;)</span>   <span class="comment">//每5秒执行一次</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span></span>&#123;</span><br><span class="line">        SimpleDateFormat df = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>); <span class="comment">//设置日期格式</span></span><br><span class="line">        System.out.println(<span class="string">&quot;定时任务，当前时刻： &quot;</span> + df.format(<span class="keyword">new</span> Date()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>启动执行如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">定时任务，当前时刻： 2020-12-23 23:37:30</span><br><span class="line">定时任务，当前时刻： 2020-12-23 23:37:35</span><br><span class="line">定时任务，当前时刻： 2020-12-23 23:37:40</span><br><span class="line">定时任务，当前时刻： 2020-12-23 23:37:45</span><br><span class="line">定时任务，当前时刻： 2020-12-23 23:37:50</span><br><span class="line">定时任务，当前时刻： 2020-12-23 23:37:55</span><br><span class="line">定时任务，当前时刻： 2020-12-23 23:38:00</span><br></pre></td></tr></table></figure></p><h3 id="Scheduled注解参数"><a href="#Scheduled注解参数" class="headerlink" title="@Scheduled注解参数"></a><code>@Scheduled</code>注解参数</h3><p>先来看下 Scheduled 源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Copyright 2002-2018 the original author or authors.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span></span><br><span class="line"><span class="comment"> * you may not use this file except in compliance with the License.</span></span><br><span class="line"><span class="comment"> * You may obtain a copy of the License at</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *      https://www.apache.org/licenses/LICENSE-2.0</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Unless required by applicable law or agreed to in writing, software</span></span><br><span class="line"><span class="comment"> * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span></span><br><span class="line"><span class="comment"> * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span></span><br><span class="line"><span class="comment"> * See the License for the specific language governing permissions and</span></span><br><span class="line"><span class="comment"> * limitations under the License.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> org.springframework.scheduling.annotation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Documented;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.ElementType;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Repeatable;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Retention;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.RetentionPolicy;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Target;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * An annotation that marks a method to be scheduled. Exactly one of</span></span><br><span class="line"><span class="comment"> * the &#123;<span class="doctag">@link</span> #cron()&#125;, &#123;<span class="doctag">@link</span> #fixedDelay()&#125;, or &#123;<span class="doctag">@link</span> #fixedRate()&#125;</span></span><br><span class="line"><span class="comment"> * attributes must be specified.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;The annotated method must expect no arguments. It will typically have</span></span><br><span class="line"><span class="comment"> * a &#123;<span class="doctag">@code</span> void&#125; return type; if not, the returned value will be ignored</span></span><br><span class="line"><span class="comment"> * when called through the scheduler.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Processing of &#123;<span class="doctag">@code</span> <span class="doctag">@Scheduled</span>&#125; annotations is performed by</span></span><br><span class="line"><span class="comment"> * registering a &#123;<span class="doctag">@link</span> ScheduledAnnotationBeanPostProcessor&#125;. This can be</span></span><br><span class="line"><span class="comment"> * done manually or, more conveniently, through the &#123;<span class="doctag">@code</span> &lt;task:annotation-driven/&gt;&#125;</span></span><br><span class="line"><span class="comment"> * element or @&#123;<span class="doctag">@link</span> EnableScheduling&#125; annotation.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;This annotation may be used as a &lt;em&gt;meta-annotation&lt;/em&gt; to create custom</span></span><br><span class="line"><span class="comment"> * &lt;em&gt;composed annotations&lt;/em&gt; with attribute overrides.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Mark Fisher</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Juergen Hoeller</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Dave Syer</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Chris Beams</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 3.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> EnableScheduling</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> ScheduledAnnotationBeanPostProcessor</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> Schedules</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.METHOD, ElementType.ANNOTATION_TYPE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Repeatable(Schedules.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Scheduled &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A special cron expression value that indicates a disabled trigger: &#123;<span class="doctag">@value</span>&#125;.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;This is primarily meant for use with $&#123;...&#125; placeholders, allowing for</span></span><br><span class="line"><span class="comment"> * external disabling of corresponding scheduled methods.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 5.1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">String CRON_DISABLED = <span class="string">&quot;-&quot;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A cron-like expression, extending the usual UN*X definition to include triggers</span></span><br><span class="line"><span class="comment"> * on the second as well as minute, hour, day of month, month and day of week.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;E.g. &#123;<span class="doctag">@code</span> &quot;0 * * * * MON-FRI&quot;&#125; means once per minute on weekdays</span></span><br><span class="line"><span class="comment"> * (at the top of the minute - the 0th second).</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;The special value &#123;<span class="doctag">@link</span> #CRON_DISABLED &quot;-&quot;&#125; indicates a disabled cron trigger,</span></span><br><span class="line"><span class="comment"> * primarily meant for externally specified values resolved by a $&#123;...&#125; placeholder.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> an expression that can be parsed to a cron schedule</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> org.springframework.scheduling.support.CronSequenceGenerator</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">String <span class="title">cron</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A time zone for which the cron expression will be resolved. By default, this</span></span><br><span class="line"><span class="comment"> * attribute is the empty String (i.e. the server&#x27;s local time zone will be used).</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> a zone id accepted by &#123;<span class="doctag">@link</span> java.util.TimeZone#getTimeZone(String)&#125;,</span></span><br><span class="line"><span class="comment"> * or an empty String to indicate the server&#x27;s default time zone</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 4.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> org.springframework.scheduling.support.CronTrigger#CronTrigger(String, java.util.TimeZone)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> java.util.TimeZone</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">String <span class="title">zone</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Execute the annotated method with a fixed period in milliseconds between the</span></span><br><span class="line"><span class="comment"> * end of the last invocation and the start of the next.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the delay in milliseconds</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">fixedDelay</span><span class="params">()</span> <span class="keyword">default</span> -1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Execute the annotated method with a fixed period in milliseconds between the</span></span><br><span class="line"><span class="comment"> * end of the last invocation and the start of the next.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the delay in milliseconds as a String value, e.g. a placeholder</span></span><br><span class="line"><span class="comment"> * or a &#123;<span class="doctag">@link</span> java.time.Duration#parse java.time.Duration&#125; compliant value</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 3.2.2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">String <span class="title">fixedDelayString</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Execute the annotated method with a fixed period in milliseconds between</span></span><br><span class="line"><span class="comment"> * invocations.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the period in milliseconds</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">fixedRate</span><span class="params">()</span> <span class="keyword">default</span> -1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Execute the annotated method with a fixed period in milliseconds between</span></span><br><span class="line"><span class="comment"> * invocations.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the period in milliseconds as a String value, e.g. a placeholder</span></span><br><span class="line"><span class="comment"> * or a &#123;<span class="doctag">@link</span> java.time.Duration#parse java.time.Duration&#125; compliant value</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 3.2.2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">String <span class="title">fixedRateString</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Number of milliseconds to delay before the first execution of a</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> #fixedRate()&#125; or &#123;<span class="doctag">@link</span> #fixedDelay()&#125; task.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the initial delay in milliseconds</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 3.2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">initialDelay</span><span class="params">()</span> <span class="keyword">default</span> -1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Number of milliseconds to delay before the first execution of a</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> #fixedRate()&#125; or &#123;<span class="doctag">@link</span> #fixedDelay()&#125; task.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the initial delay in milliseconds as a String value, e.g. a placeholder</span></span><br><span class="line"><span class="comment"> * or a &#123;<span class="doctag">@link</span> java.time.Duration#parse java.time.Duration&#125; compliant value</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 3.2.2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">String <span class="title">initialDelayString</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="cron-参数接收一个cron表达式，cron表达式是一个字符串，字符串以5或6个空格隔开，分开共6或7个域，每一个域代表一个含义。"><a href="#cron-参数接收一个cron表达式，cron表达式是一个字符串，字符串以5或6个空格隔开，分开共6或7个域，每一个域代表一个含义。" class="headerlink" title="cron 参数接收一个cron表达式，cron表达式是一个字符串，字符串以5或6个空格隔开，分开共6或7个域，每一个域代表一个含义。"></a><code>cron</code> 参数接收一个cron表达式，cron表达式是一个字符串，字符串以5或6个空格隔开，分开共6或7个域，每一个域代表一个含义。</h4><p>cron 表达式语法：</p><p>格式：<strong>[秒] [分] [小时] [日] [月] [周] [年]</strong></p><table><thead><tr><th style="text-align:left">序号</th><th style="text-align:left">说明</th><th style="text-align:left">是否必填</th><th style="text-align:left">允许填写的值</th><th style="text-align:left">允许的通配符</th></tr></thead><tbody><tr><td style="text-align:left">1</td><td style="text-align:left">秒</td><td style="text-align:left">是</td><td style="text-align:left">0-59</td><td style="text-align:left">, - * /</td></tr><tr><td style="text-align:left">2</td><td style="text-align:left">分</td><td style="text-align:left">是</td><td style="text-align:left">0-59</td><td style="text-align:left">, - * /</td></tr><tr><td style="text-align:left">3</td><td style="text-align:left">小时</td><td style="text-align:left">是</td><td style="text-align:left">0-23</td><td style="text-align:left">, - * /</td></tr><tr><td style="text-align:left">4</td><td style="text-align:left">日</td><td style="text-align:left">是</td><td style="text-align:left">1-31</td><td style="text-align:left">, - * ? / L W</td></tr><tr><td style="text-align:left">5</td><td style="text-align:left">月</td><td style="text-align:left">是</td><td style="text-align:left">1-12 or JAN-DEC</td><td style="text-align:left">, - * /</td></tr><tr><td style="text-align:left">6</td><td style="text-align:left">周</td><td style="text-align:left">是</td><td style="text-align:left">1-7 or SUN-SAT</td><td style="text-align:left">, - * ? / L #</td></tr><tr><td style="text-align:left">7</td><td style="text-align:left">年</td><td style="text-align:left">否</td><td style="text-align:left">empty 或 1970-2099</td><td style="text-align:left">, - * /</td></tr></tbody></table><p>特殊字符说明：</p><ul><li><strong>秒</strong>  允许值范围: 0~59 ,不允许为空值，若值不合法，调度器将抛出SchedulerException异常<ul><li><code>*</code>  每隔1秒钟触发</li><li><code>,</code>  在指定的秒数触发，比如”0,15,45”代表0秒、15秒和45秒时触发任务</li><li><code>-</code>  在指定的范围内触发，比如”25-45”代表从25秒开始触发到45秒结束触发，每隔1秒触发1次</li><li><code>/</code>  代表触发步进(step)，”/“前面的值代表初始值(“<em>“等同”0”)，后面的值代表偏移量，比如”0/20”或者”</em>/20”代表从0秒钟开始，每隔20秒钟触发1次，即0秒触发1次，20秒触发1次，40秒触发1次；”5/20”代表5秒触发1次，25秒触发1次，45秒触发1次；”10-45/20”代表在[10,45]内步进20秒命中的时间点触发，即10秒触发1次，30秒触发1次</li></ul></li><li><strong>分钟</strong>  允许值范围: 0~59 ,不允许为空值，若值不合法，调度器将抛出SchedulerException异常<ul><li><code>*</code>  代表每隔1分钟触发</li><li><code>,</code>  代表在指定的分钟触发，比如”10,20,40”代表10分钟、20分钟和40分钟时触发任务</li><li><code>-</code>  代表在指定的范围内触发，比如”5-30”代表从5分钟开始触发到30分钟结束触 发，每隔1分钟触发</li><li><code>/</code>  代表触发步进(step)，”/“前面的值代表初始值(“<em>“等同”0”)，后面的值代表偏移量，比如”0/25”或者”</em>/25”代表从0分钟开始，每隔25分钟触发1次，即0分钟触发1次，第25分钟触发1次，第50分钟触发1次；”5/25”代表5分钟触发1次，30分钟触发1次，55分钟触发1次；”10-45/20”代表在[10,45]内步进20分钟命中的时间点触发，即10分钟触发1次，30分钟触发1次</li></ul></li><li><strong>小时</strong>  允许值范围: 0~23 ,不允许为空值，若值不合法，调度器将抛出SchedulerException异常<ul><li><code>*</code>  代表每隔1小时触发</li><li><code>,</code>  代表在指定的时间点触发，比如”10,20,23”代表10点钟、20点钟和23点触发任务</li><li><code>-</code>  代表在指定的时间段内触发，比如”20-23”代表从20点开始触发到23点结束触发，每隔1小时触发</li><li><code>/</code>  代表触发步进(step)，”/“前面的值代表初始值(“<em>“等同”0”)，后面的值代表偏移量，比如”0/1”或者”</em>/1”代表从0点开始触发，每隔1小时触发1次；”1/2”代表从1点开始触发，以后每隔2小时触发一次</li></ul></li><li><strong>日期</strong>  允许值范围: 1~12 (JAN-DEC),不允许为空值，若值不合法，调度器将抛出SchedulerException异常<ul><li><code>*</code>  代表每个月都触发</li><li><code>,</code>  代表在指定的月份触发，比如”1,6,12”代表1月份、6月份和12月份触发任务</li><li><code>-</code>  代表在指定的月份范围内触发，比如”1-6”代表从1月份开始触发到6月份结束触发，每隔1个月触发</li><li><code>/</code>  代表触发步进(step)，”/“前面的值代表初始值(“<em>“等同”1”)，后面的值代表偏移量，比如”1/2”或者”</em>/2”代表从1月份开始触发，每隔2个月触发1次；”6/6”代表从6月份开始触发，以后每隔6个月触发一次；”1-6/12”表达式意味着每年1月份触发</li></ul></li><li><strong>星期</strong>  允许值范围: 1~7 (SUN-SAT),1代表星期天(一星期的第一天)，以此类推，7代表星期六(一星期的最后一天)，不允许为空值，若值不合法，调度器将抛出SchedulerException异常<ul><li><code>*</code>  代表每星期都触发</li><li><code>,</code>  代表在指定的星期约定触发，比如”1,3,5”代表星期天、星期二和星期四触发</li><li><code>-</code>  代表在指定的星期范围内触发，比如”2-4”代表从星期一开始触发到星期三结束触发，每隔1天触发</li><li><code>/</code>  代表触发步进(step)，”/“前面的值代表初始值(“<em>“等同”1”)，后面的值代表偏移量，比如”1/3”或者”</em>/3”代表从星期天开始触发，每隔3天触发1次；”1-5/2”表达式意味着在[1,5]范围内，每隔2天触发，即星期天、星期二、星期四触发</li><li><code>?</code>  与{日期}互斥，即意味着若明确指定{日期}触发，则表示{星期}无意义，以免引起冲突和混乱</li><li><code>L</code>  如果{星期}占位符如果是”L”，即意味着星期的的最后一天触发，即星期六触发，L= 7或者 L = SAT，因此，”5L”意味着一个月的最后一个星期四触发</li><li><code>#</code>  用来指定具体的周数，”#”前面代表星期，”#”后面代表本月第几周，比如”2#2”表示本月第二周的星期一，”5#3”表示本月第三周的星期四，因此，”5L”这种形式只不过是”#”的特殊形式而已</li></ul></li><li><strong>年份</strong>  允许值范围: 1970~2099 ,允许为空，若值不合法，调度器将抛出SchedulerException异常<ul><li><code>*</code>  代表每年都触发</li><li><code>,</code>  代表在指定的年份才触发，比如”2011,2012,2013”代表2011年、2012年和2013年触发任务</li><li><code>-</code>  代表在指定的年份范围内触发，比如”2011-2020”代表从2011年开始触发到2020年结束触发，每隔1年触发</li><li><code>/</code>  代表触发步进(step)，”/“前面的值代表初始值(“<em>“等同”1970”)，后面的值代表偏移量，比如”2011/2”或者”</em>/2”代表从2011年开始触发，每隔2年触发1次 </li></ul></li></ul><p><strong>注意：除了{日期}和{星期}可以使用”?”来实现互斥，表达无意义的信息之外，其他占位符都要具有具体的时间含义，且依赖关系为：年-&gt;月-&gt;日期(星期)-&gt;小时-&gt;分钟-&gt;秒数</strong></p><ul><li><code>*</code>字符被用来指定所有的值。如：<code>*</code>在分钟的字段域里表示“每分钟”。</li><li><code>?</code>字符只在日期域和星期域中使用。它被用来指定“非明确的值”。当你需要通过在这两个域中的一个来指定一些东西的时候，它是有用的。看下面的例子你就会明白。 月份中的日期和星期中的日期这两个元素时互斥的一起应该通过设置一个问号来表明不想设置那个字段。</li><li><code>-</code>字符被用来指定一个范围。如：“10-12”在小时域意味着“10点、11点、12点”。</li><li><code>,</code>字符被用来指定另外的值。如：“MON,WED,FRI”在星期域里表示”星期一、星期三、星期五”。</li><li><code>/</code>字符用于指定增量。如：“0/15”在秒域意思是每分钟的0，15，30和45秒。“5/15”在分钟域表示每小时的5，20，35和50。符号“<em>”在“/”前面（如：</em>/10）等价于0在“/”前面（如：0/10）。记住一条本质：表达式的每个数值域都是一个有最大值和最小值的集合，如：秒域和分钟域的集合是0-59，日期域是1-31，月份域是1-12。字符“/”可以帮助你在每个字符域中取相应的数值。如：“7/6”在月份域的时候只有当7月的时候才会触发，并不是表示每个6月。</li><li><code>L</code>是‘last’的省略写法可以表示day-of-month和day-of-week域，但在两个字段中的意思不同，例如day-of-month域中表示一个月的最后一天。如果在day-of-week域表示‘7’或者‘SAT’，如果在day-of-week域中前面加上数字，它表示一个月的最后几天，例如‘6L’就表示一个月的最后一个星期五。</li><li><code>W</code>字符只允许日期域出现。这个字符用于指定日期的最近工作日。例如：如果你在日期域中写 “15W”，表示：这个月15号最近的工作日。所以，如果15号是周六，则任务会在14号触发。如果15好是周日，则任务会在周一也就是16号触发。如果是在日期域填写“1W”即使1号是周六，那么任务也只会在下周一，也就是3号触发，“W”字符指定的最近工作日是不能够跨月份的。字符“W”只能配合一个单独的数值使用，不能够是一个数字段，如：1-15W是错误的。</li></ul><blockquote><p><code>L</code>和<code>W</code>可以在日期域中联合使用，LW表示这个月最后一周的工作日。</p></blockquote><ul><li><code>#</code>字符只允许在星期域中出现。这个字符用于指定本月的某某天。例如：“6#3”表示本月第三周的星期五（6表示星期五，3表示第三周）。“2#1”表示本月第一周的星期一。“4#5”表示第五周的星期三。</li><li><code>C</code>字符允许在日期域和星期域出现。这个字符依靠一个指定的“日历”。也就是说这个表达式的值依赖于相关的“日历”的计算结果，如果没有“日历”关联，则等价于所有包含的“日历”。如：日期域是“5C”表示关联“日历”中第一天，或者这个月开始的第一天的后5天。星期域是“1C”表示关联“日历”中第一天，或者星期的第一天的后1天，也就是周日的后一天（周一）。</li></ul><p><strong>表达式举例</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&quot;0 0 12 * * ?&quot; 每天中午12点触发</span><br><span class="line">&quot;0 15 10 ? * *&quot; 每天上午10:15触发</span><br><span class="line">&quot;0 15 10 * * ?&quot; 每天上午10:15触发</span><br><span class="line">&quot;0 15 10 * * ? *&quot; 每天上午10:15触发</span><br><span class="line">&quot;0 15 10 * * ? 2005&quot; 2005年的每天上午10:15触发</span><br><span class="line">&quot;0 * 14 * * ?&quot; 在每天下午2点到下午2:59期间的每1分钟触发</span><br><span class="line">&quot;0 0&#x2F;5 14 * * ?&quot; 在每天下午2点到下午2:55期间的每5分钟触发</span><br><span class="line">&quot;0 0&#x2F;5 14,18 * * ?&quot; 在每天下午2点到2:55期间和下午6点到6:55期间的每5分钟触发</span><br><span class="line">&quot;0 0-5 14 * * ?&quot; 在每天下午2点到下午2:05期间的每1分钟触发</span><br><span class="line">&quot;0 10,44 14 ? 3 WED&quot; 每年三月的星期三的下午2:10和2:44触发</span><br><span class="line">&quot;0 15 10 ? * MON-FRI&quot; 周一至周五的上午10:15触发</span><br><span class="line">&quot;0 15 10 15 * ?&quot; 每月15日上午10:15触发</span><br><span class="line">&quot;0 15 10 L * ?&quot; 每月最后一日的上午10:15触发</span><br><span class="line">&quot;0 15 10 ? * 6L&quot; 每月的最后一个星期五上午10:15触发</span><br><span class="line">&quot;0 15 10 ? * 6L 2002-2005&quot; 2002年至2005年的每月的最后一个星期五上午10:15触</span><br><span class="line">&quot;0 15 10 ? * 6#3&quot; 每月的第三个星期五上午10:15触发</span><br></pre></td></tr></table></figure></p><p>在线Cron表达式生成器 : <a href="https://cron.qqe2.com/">https://cron.qqe2.com/</a></p><h2 id="基于接口SchedulingConfigurer"><a href="#基于接口SchedulingConfigurer" class="headerlink" title="基于接口SchedulingConfigurer"></a>基于接口SchedulingConfigurer</h2><p>Spring 中，创建定时任务除了使用<code>@Scheduled</code> 注解外，还可以使用 <code>SchedulingConfigurer</code>。</p><p><code>@Schedule</code> 注解有一个缺点，其定时的时间不能动态的改变，而基于 <code>SchedulingConfigurer</code> 接口的方式可以做到。<code>SchedulingConfigurer</code> 接口可以实现在<code>@Configuration</code> 类上，同时不要忘了，还需要<code>@EnableScheduling</code> 注解的支持。</p><p>该接口的实现方法如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configureTasks</span><span class="params">(ScheduledTaskRegistrar taskRegistrar)</span></span></span><br></pre></td></tr></table></figure><br>方法包含定时任务，延时任务，基于 <code>Cron</code> 表达式的任务，以及 <code>Trigger</code> 触发的任务。</p><p>下面演示了使用方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(value = &quot;com.learn&quot;)</span></span><br><span class="line"><span class="meta">@EnableScheduling</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Config</span> <span class="keyword">implements</span> <span class="title">SchedulingConfigurer</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configureTasks</span><span class="params">(ScheduledTaskRegistrar taskRegistrar)</span> </span>&#123;</span><br><span class="line">taskRegistrar.addFixedRateTask(() -&gt; System.out.println(<span class="string">&quot;执行定时任务1: &quot;</span> + <span class="keyword">new</span> Date()), <span class="number">1000</span>);</span><br><span class="line">TriggerTask triggrtTask = <span class="keyword">new</span> TriggerTask( <span class="comment">// 任务内容.拉姆达表达式</span></span><br><span class="line">() -&gt; &#123;System.out.println(<span class="string">&quot;执行定时任务2: &quot;</span> + <span class="keyword">new</span> Date());&#125;,</span><br><span class="line"><span class="comment">// 设置触发器，这里是一个拉姆达表达式，传入的TriggerContext类型，返回的是Date类型</span></span><br><span class="line">triggerContext -&gt; &#123;</span><br><span class="line"><span class="comment">// 2.3 返回执行周期(Date)</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> CronTrigger(<span class="string">&quot;*/2 * * * * ?&quot;</span>).nextExecutionTime(triggerContext);</span><br><span class="line">&#125;);</span><br><span class="line"> </span><br><span class="line">taskRegistrar.addTriggerTask(triggrtTask);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>默认的，<code>SchedulingConfigurer</code> 使用的也是单线程的方式，如果需要配置多线程，则需要指定 <code>PoolSize</code>，加入如下代码即可：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configureTasks</span><span class="params">(ScheduledTaskRegistrar taskRegistrar)</span> </span>&#123;</span><br><span class="line">ThreadPoolTaskScheduler taskScheduler = <span class="keyword">new</span> ThreadPoolTaskScheduler();</span><br><span class="line">taskScheduler.setPoolSize(<span class="number">10</span>);</span><br><span class="line">taskScheduler.initialize();</span><br><span class="line">taskRegistrar.setTaskScheduler(taskScheduler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>动态修改定时规则</p><h2 id="基于注解设定多线程定时任务"><a href="#基于注解设定多线程定时任务" class="headerlink" title="基于注解设定多线程定时任务"></a>基于注解设定多线程定时任务</h2><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://blog.csdn.net/pan_junbiao/article/details/109399280">SpringBoot使用@Scheduled注解实现定时任务</a></li><li><a href="https://www.jianshu.com/p/e9ce1a7e1ed1">Cron表达式的详细用法</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Spring 3.0 版本之后自带定时任务，提供了@EnableScheduling注解和@Scheduled注解来实现定时任务功能。&lt;/p&gt;
&lt;p&gt;使用SpringBoot创建定时任务非常简单，目前主要有以下三种创建方式：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;基于注解（@Scheduled）&lt;/li&gt;
&lt;li&gt;基于接口（SchedulingConfigurer） 前者相信大家都很熟悉，但是实际使用中我们往往想从数据库中读取指定时间来动态执行定时任务，这时候基于接口的定时任务就派上用场了。&lt;/li&gt;
&lt;li&gt;基于注解设定多线程定时任务&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="Java" scheme="https://sogrey.github.io/categories/Java/"/>
    
    
      <category term="Java" scheme="https://sogrey.github.io/tags/Java/"/>
    
      <category term="Spring boot" scheme="https://sogrey.github.io/tags/Spring-boot/"/>
    
      <category term="Scheduled" scheme="https://sogrey.github.io/tags/Scheduled/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot注解简介</title>
    <link href="https://sogrey.github.io/article/SpringBoot%E6%B3%A8%E8%A7%A3%E7%AE%80%E4%BB%8B/"/>
    <id>https://sogrey.github.io/article/SpringBoot注解简介/</id>
    <published>2020-12-15T04:07:03.000Z</published>
    <updated>2020-12-21T15:42:58.214Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>使用注解的优势：</p><ol><li>采用纯java代码，不在需要配置繁杂的xml文件</li><li>在配置中也可享受面向对象带来的好处</li><li>类型安全对重构可以提供良好的支持</li><li>减少复杂配置文件的同时亦能享受到springIoC容器提供的功能</li></ol><span id="more"></span><h2 id="一、注解-annotations-列表"><a href="#一、注解-annotations-列表" class="headerlink" title="一、注解(annotations)列表"></a>一、注解(annotations)列表</h2><p>1、<code>@SpringBootApplication</code></p><p>包含了<code>@ComponentScan</code>、<code>@Configuration</code>和<code>@EnableAutoConfiguration</code>注解。<br>其中<code>@ComponentScan</code>让<code>Spring Boot</code>扫描到<code>Configuration</code>类并把它加入到程序上下文。</p><p>2、<code>@ComponentScan</code></p><p>组件扫描，可自动发现和装配一些<code>Bean</code>。</p><p>3、<code>@Configuration</code></p><p>等同于<code>Spring</code>的<code>XML</code>配置文件；使用<code>Java</code>代码可以检查类型安全。</p><p>4、<code>@EnableAutoConfiguration</code></p><p>自动配置</p><p>5、<code>@RestController</code></p><p>该注解是<code>@Controller</code>和<code>@ResponseBody</code>的合集,表示这是个控制器<code>Bean</code>,并且是将函数的返回值直接填入<code>HTTP</code>响应体中,是<code>REST</code>风格的控制器。</p><p>6、<code>@Autowired</code></p><p>自动导入。</p><p>7、<code>@PathVariable</code></p><p>获取参数。</p><p>8、<code>@JsonBackReference</code></p><p>解决嵌套外链问题。</p><p>9、<code>@RepositoryRestResourcepublic</code></p><p>配合spring-boot-starter-data-rest使用。</p><h2 id="二、注解-annotations-详解"><a href="#二、注解-annotations-详解" class="headerlink" title="二、注解(annotations)详解"></a>二、注解(annotations)详解</h2><p>1、<code>@SpringBootApplication</code>：申明让<code>Spring Boot</code>自动给程序进行必要的配置，这个配置等同于：<code>@Configuration</code> ，<code>@EnableAutoConfiguration</code> 和 <code>@ComponentScan</code> 三个配置。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import org.springframework.boot.SpringApplication;</span><br><span class="line">import org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"></span><br><span class="line">@SpringBootApplication &#x2F;&#x2F; same as @Configuration @EnableAutoConfiguration @ComponentScan</span><br><span class="line">public class Application &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(Application.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、<code>@ResponseBody</code>：表示该方法的返回结果直接写入<code>HTTP Response Body</code>中，一般在异步获取数据时使用，用于构建<code>RESTful</code>的<code>api</code>。</p><p>在使用<code>@RequestMapping</code>后，返回值通常解析为跳转路径，加上<code>@ResponseBody</code>后返回结果不会被解析为跳转路径，而是直接写入<code>HTTP Response Body</code>中。</p><p>比如异步获取<code>json</code>数据，加上<code>@ResponseBody</code>后，会直接返回<code>json</code>数据。</p><p>该注解一般会配合<code>@RequestMapping</code>一起使用。</p><p>示例代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@RequestMapping(“&#x2F;test”)</span><br><span class="line">@ResponseBody</span><br><span class="line">public String test()&#123;</span><br><span class="line">    return ”ok”;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、<code>@Controller</code>：用于定义控制器类，在<code>spring</code> 项目中由控制器负责将用户发来的<code>URL</code>请求转发到对应的服务接口（<code>service</code>层）</p><p>一般这个注解在类中，通常方法需要配合注解<code>@RequestMapping</code>。</p><p>示例代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@Controller</span><br><span class="line">@RequestMapping(“&#x2F;demoInfo”)</span><br><span class="line">publicclass DemoController &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private DemoInfoService demoInfoService;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(&quot;&#x2F;hello&quot;)</span><br><span class="line">    public String hello(Map map)&#123;</span><br><span class="line">        System.out.println(&quot;DemoController.hello()&quot;);</span><br><span class="line">        map.put(&quot;hello&quot;,&quot;from TemplateController.helloHtml&quot;);</span><br><span class="line">        &#x2F;&#x2F; 会使用hello.html或者hello.ftl模板进行渲染显示.</span><br><span class="line">        return&quot;&#x2F;hello&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4、<code>@RestController</code>：用于标注控制层组件(如<code>struts</code>中的<code>action</code>)，<code>@ResponseBody</code>和<code>@Controller</code>的合集。</p><p>示例代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line">@RestController</span><br><span class="line">@RequestMapping(“&#x2F;demoInfo2”)</span><br><span class="line">publicclass DemoController2 &#123;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(&quot;&#x2F;test&quot;)</span><br><span class="line">    public String test()&#123;</span><br><span class="line">        return&quot;ok&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5、<code>@RequestMapping</code>：提供路由信息，负责<code>URL</code>到<code>Controller</code>中的具体函数的映射。</p><p>6、<code>@EnableAutoConfiguration</code>：<code>Spring Boot</code>自动配置（<code>auto-configuration</code>）：尝试根据你添加的<code>jar</code>依赖自动配置你的<code>Spring</code>应用。</p><p>例如，如果你的<code>classpath</code>下存在HSQLDB，并且你没有手动配置任何数据库连接<code>beans</code>，那么我们将自动配置一个内存型（<code>in-memory</code>）数据库”。</p><p>你可以将<code>@EnableAutoConfiguration</code>或者<code>@SpringBootApplication</code>注解添加到一个<code>@Configuration</code>类上来选择自动配置。</p><p>如果发现应用了你不想要的特定自动配置类，你可以使用<code>@EnableAutoConfiguration</code>注解的排除属性来禁用它们。</p><p>搜索Java知音公众号，回复“后端面试”，送你一份Java面试题宝典.pdf</p><p>7、<code>@ComponentScan</code>：表示将该类自动发现扫描组件。</p><p>个人理解相当于，如果扫描到有<code>@Component</code>、<code>@Controller</code>、<code>@Service</code>等这些注解的类，并注册为<code>Bean</code>，可以自动收集所有的<code>Spring</code>组件，包括<code>@Configuration</code>类。</p><p>我们经常使用<code>@ComponentScan</code>注解搜索<code>beans</code>，并结合<code>@Autowired</code>注解导入。可以自动收集所有的<code>Spring</code>组件，包括<code>@Configuration</code>类。</p><p>如果没有配置的话，<code>Spring Boot</code>会扫描启动类所在包下以及子包下的使用了<code>@Service</code>、<code>@Repository</code>等注解的类。</p><p>8、<code>@Configuration</code>：相当于传统的<code>xml</code>配置文件，如果有些第三方库需要用到<code>xml</code>文件，建议仍然通过<code>@Configuration</code>类作为项目的配置主类——可以使用<code>@ImportResource</code>注解加载<code>xml</code>配置文件。</p><p>9、<code>@Import</code>：用来导入其他配置类。</p><p>10、<code>@ImportResource</code>：用来加载<code>xml</code>配置文件。</p><p>11、<code>@Autowired</code>：自动导入依赖的<code>bean</code></p><p>12、<code>@Service</code>：一般用于修饰<code>service</code>层的组件</p><p>13、<code>@Repository</code>：使用<code>@Repository</code>注解可以确保<code>DAO</code>或者<code>repositories</code>提供异常转译，这个注解修饰的<code>DAO</code>或者<code>repositories</code>类会被<code>ComponetScan</code>发现并配置，同时也不需要为它们提供<code>XML</code>配置项。</p><p>14、<code>@Bean</code>：用<code>@Bean</code>标注方法等价于<code>XML</code>中配置的<code>bean</code>。</p><p>15、<code>@Value</code>：注入<code>Spring boot</code> <code>application.properties</code>配置的属性的值。示例代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@Value(value &#x3D; “#&#123;message&#125;”)</span><br><span class="line">private String message;</span><br></pre></td></tr></table></figure><p>16、<code>@Inject</code>：等价于默认的<code>@Autowired</code>，只是没有<code>required</code>属性；</p><p>17、<code>@Component</code>：泛指组件，当组件不好归类的时候，我们可以使用这个注解进行标注。</p><p>18、<code>@Bean</code>：相当于<code>XML</code>中的,放在方法的上面，而不是类，意思是产生一个<code>bean</code>,并交给<code>spring</code>管理。</p><p>19、<code>@AutoWired</code>：自动导入依赖的<code>bean</code>。<code>byType</code>方式。把配置好的<code>Bean</code>拿来用，完成属性、方法的组装，它可以对类成员变量、方法及构造函数进行标注，完成自动装配的工作。当加上（<code>required=false</code>）时，就算找不到<code>bean</code>也不报错。</p><p>20、<code>@Qualifier</code>：当有多个同一类型的<code>Bean</code>时，可以用<code>@Qualifier(“name”)</code>来指定。与<code>@Autowired</code>配合使用。<code>@Qualifier</code>限定描述符除了能根据名字进行注入，但能进行更细粒度的控制如何选择候选者，具体使用方式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@Autowired</span><br><span class="line">@Qualifier(value &#x3D; “demoInfoService”)</span><br><span class="line">private DemoInfoService demoInfoService;</span><br></pre></td></tr></table></figure><p>21、<code>@Resource(name=”name”,type=”type”)</code>：没有括号内内容的话，默认<code>byName</code>。与<code>@Autowired</code>干类似的事。</p><h2 id="三、JPA注解"><a href="#三、JPA注解" class="headerlink" title="三、JPA注解"></a>三、JPA注解</h2><p>1、<code>@Entity</code>：<code>@Table(name=”“)</code>：表明这是一个实体类。一般用于<code>jpa</code>这两个注解一般一块使用，但是如果表名和实体类名相同的话，<code>@Table</code>可以省略。</p><p>2、<code>@MappedSuperClass</code>:用在确定是父类的<code>entity</code>上。父类的属性子类可以继承。</p><p>3、<code>@NoRepositoryBean</code>:一般用作父类的<code>repository</code>，有这个注解，<code>Spring</code>不会去实例化该<code>repository</code>。</p><p>4、<code>@Column</code>：如果字段名与列名相同，则可以省略。</p><p>5、<code>@Id</code>：表示该属性为主键。</p><p>6、<code>@GeneratedValue(strategy=GenerationType.SEQUENCE,generator= “repair_seq”)</code>：表示主键生成策略是<code>sequence</code>（可以为<code>Auto</code>、<code>IDENTITY</code>、<code>native</code>等，<code>Auto</code>表示可在多个数据库间切换），指定<code>sequence</code>的名字是<code>repair_seq</code>。</p><p>7、<code>@SequenceGeneretor(name = “repair_seq”, sequenceName = “seq_repair”, allocationSize = 1)</code>：<code>name</code>为<code>sequence</code>的名称，以便使用，<code>sequenceName</code>为数据库的<code>sequence</code>名称，两个名称可以一致。</p><p>8、<code>@Transient</code>：表示该属性并非一个到数据库表的字段的映射,<code>ORM</code>框架将忽略该属性。</p><p>如果一个属性并非数据库表的字段映射,就务必将其标示为<code>@Transient</code>,否则,<code>ORM</code>框架默认其注解为<code>@Basic</code>。</p><p>9、<code>@Basic(fetch=FetchType.LAZY)</code>：标记可以指定实体属性的加载方式。</p><p>10、<code>@JsonIgnore</code>：作用是<code>json</code>序列化时将<code>Java bean</code>中的一些属性忽略掉,序列化和反序列化都受影响。</p><p>11、<code>@JoinColumn（name=”loginId”）</code>:一对一：本表中指向另一个表的外键。一对多：另一个表指向本表的外键。</p><p>12、<code>@OneToOne、@OneToMany、@ManyToOne</code>：对应<code>hibernate</code>配置文件中的一对一，一对多，多对一。</p><h2 id="四、SpringMVC相关注解"><a href="#四、SpringMVC相关注解" class="headerlink" title="四、SpringMVC相关注解"></a>四、SpringMVC相关注解</h2><p>1、<code>@RequestMapping</code>：<code>@RequestMapping(“/path”)</code>表示该控制器处理所有“/path”的UR L请求。</p><p><code>RequestMapping</code>是一个用来处理请求地址映射的注解，可用于类或方法上。</p><p>用于类上，表示类中的所有响应请求的方法都是以该地址作为父路径。该注解有六个属性：</p><ul><li><code>params</code>:指定<code>request</code>中必须包含某些参数值是，才让该方法处理。</li><li><code>headers</code>:指定<code>request</code>中必须包含某些指定的<code>header</code>值，才能让该方法处理请求。</li><li><code>value</code>:指定请求的实际地址，指定的地址可以是<code>URI Template</code> 模式</li><li><code>method</code>:指定请求的method类型， <code>GET、POST、PUT、DELETE</code>等</li><li><code>consumes</code>:指定处理请求的提交内容类型（<code>Content-Type</code>），如<code>application/json,text/html</code>;</li><li><code>produces</code>:指定返回的内容类型，仅当<code>request</code>请求头中的(<code>Accept</code>)类型中包含该指定类型才返回。</li></ul><p>2、<code>@RequestParam</code>：用在方法的参数前面。</p><p>3、<code>@PathVariable</code>:路径变量。如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">RequestMapping(“user&#x2F;get&#x2F;&#123;macAddress&#125;”)</span><br><span class="line">public String getByMacAddress(@PathVariable String macAddress)&#123;</span><br><span class="line">    &#x2F;&#x2F;do something;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参数与大括号里的名字一样要相同。</p><h2 id="五、全局异常处理"><a href="#五、全局异常处理" class="headerlink" title="五、全局异常处理"></a>五、全局异常处理</h2><p><code>@ControllerAdvice</code>：包含<code>@Component</code>。可以被扫描到。统一处理异常。</p><p><code>@ExceptionHandler（Exception.class）</code>：用在方法上面表示遇到这个异常就执行以下方法。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用注解的优势：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;采用纯java代码，不在需要配置繁杂的xml文件&lt;/li&gt;
&lt;li&gt;在配置中也可享受面向对象带来的好处&lt;/li&gt;
&lt;li&gt;类型安全对重构可以提供良好的支持&lt;/li&gt;
&lt;li&gt;减少复杂配置文件的同时亦能享受到springIoC容器提供的功能&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="Java" scheme="https://sogrey.github.io/categories/Java/"/>
    
    
      <category term="Java" scheme="https://sogrey.github.io/tags/Java/"/>
    
      <category term="Spring boot" scheme="https://sogrey.github.io/tags/Spring-boot/"/>
    
  </entry>
  
  <entry>
    <title>Linux下如何创建文件</title>
    <link href="https://sogrey.github.io/article/Linux%E4%B8%8B%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E6%96%87%E4%BB%B6/"/>
    <id>https://sogrey.github.io/article/Linux下如何创建文件/</id>
    <published>2020-12-10T07:48:11.000Z</published>
    <updated>2020-12-21T15:42:58.212Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在 Linux 上，包括设备在内的一切皆文件。Linux用户每天都会多次执行创建文件，但在linux上右键菜单中只有创建文件夹（我们也可以使用<code>mkdir</code>命令创建），但并没有创建文件的菜单。</p><span id="more"></span><p>创建文件可以通过以下六个方式来完成。</p><ul><li><code>&gt;</code>：标准重定向符允许我们创建一个 0KB 的空文件。</li><li><code>touch</code>：如果文件不存在的话，<code>touch</code> 命令将会创建一个 0KB 的空文件。</li><li><code>echo</code>：通过一个参数显示文本的某行。</li><li><code>printf</code>：用于显示在终端给定的文本。</li><li><code>cat</code>：它串联并打印文件到标准输出。</li><li><code>vi</code>/<code>vim</code>：Vim 是一个向上兼容 Vi 的文本编辑器。它常用于编辑各种类型的纯文本。</li><li><code>nano</code>：是一个简小且用户友好的编辑器。它复制了 <code>pico</code> 的外观和优点，但它是自由软件。</li><li><code>head</code>：用于打印一个文件开头的一部分。</li><li><code>tail</code>：用于打印一个文件的最后一部分。</li><li><code>truncate</code>：用于缩小或者扩展文件的尺寸到指定大小。</li></ul><h3 id="使用重定向符（-gt-）创建一个文件"><a href="#使用重定向符（-gt-）创建一个文件" class="headerlink" title="使用重定向符（&gt;）创建一个文件"></a>使用重定向符（&gt;）创建一个文件</h3><p>标准重定向符允许我们创建一个 0KB 的空文件。它通常用于重定向一个命令的输出到一个新文件中。在没有命令的情况下使用重定向符号时，它会创建一个文件。</p><p>但是它不允许你在创建文件时向其中输入任何文本。然而它对于不是很勤劳的管理员是非常简单有用的。只需要输入重定向符后面跟着你想要的文件名。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ &gt; demo.txt</span><br></pre></td></tr></table></figure><p>使用 <code>ls</code> 命令查看刚刚创建的文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ls -lh demo.txt</span><br><span class="line">-rw-rw-r--. 1 sogrey sogrey 0 12月 10 18:33 demo.txt</span><br></pre></td></tr></table></figure><h3 id="使用-touch-命令创建一个文件"><a href="#使用-touch-命令创建一个文件" class="headerlink" title="使用 touch 命令创建一个文件"></a>使用 touch 命令创建一个文件</h3><p><code>touch</code> 命令常用于将每个文件的访问和修改时间更新为当前时间。</p><p>如果指定的文件名不存在，将会创建一个新的文件。<code>touch</code> 不允许我们在创建文件的同时向其中输入一些文本。它默认创建一个 0KB 的空文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ touch demo.txt</span><br></pre></td></tr></table></figure><p>使用 <code>ls</code> 命令查看刚刚创建的文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ls -lh demo.txt</span><br><span class="line">-rw-rw-r--. 1 sogrey sogrey 0 12月 10 18:33 demo.txt</span><br></pre></td></tr></table></figure><h3 id="在-Linux-上使用-echo-命令创建一个文件"><a href="#在-Linux-上使用-echo-命令创建一个文件" class="headerlink" title="在 Linux 上使用 echo 命令创建一个文件"></a>在 Linux 上使用 echo 命令创建一个文件</h3><p><code>echo</code> 内置于大多数的操作系统中。它常用于脚本、批处理文件，以及作为插入文本的单个命令的一部分。</p><p>它允许你在创建一个文件时就向其中输入一些文本。当然也允许你在之后向其中输入一些文本。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">&quot;Love you.&quot;</span> &gt; demo.txt</span><br></pre></td></tr></table></figure><p>使用 <code>ls</code> 命令查看刚刚创建的文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ls -lh demo.txt</span><br><span class="line">-rw-rw-r--. 1 sogrey sogrey 10 12月 10 18:38 demo.txt</span><br></pre></td></tr></table></figure><p>可以使用 <code>cat</code> 命令查看文件的内容。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cat demo.txt</span><br><span class="line">Love you.</span><br></pre></td></tr></table></figure><p>你可以使用两个重定向符 (<code>&gt;&gt;</code>) 添加其他内容到同一个文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">&quot;Love you,too.&quot;</span> &gt;&gt; demo.txt</span><br></pre></td></tr></table></figure><p>你可以使用 <code>cat</code> 命令查看添加的内容。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ cat demo.txt</span><br><span class="line">Love you.</span><br><span class="line">Love you,too.</span><br></pre></td></tr></table></figure><h3 id="使用-printf-命令创建一个新的文件"><a href="#使用-printf-命令创建一个新的文件" class="headerlink" title="使用 printf 命令创建一个新的文件"></a>使用 printf 命令创建一个新的文件</h3><p><code>printf</code> 命令也可以以类似 <code>echo</code> 的方式执行。</p><p><code>printf</code> 命令常用来显示在终端窗口给出的字符串。<code>printf</code> 可以有格式说明符、转义序列或普通字符。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">printf</span> <span class="string">&quot;Love you.\n&quot;</span> &gt; demo.txt</span><br></pre></td></tr></table></figure><p>使用 <code>ls</code> 命令查看刚刚创建的文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ls -lh demo.txt</span><br><span class="line">-rw-rw-r--. 1 sogrey sogrey 10 12月 10 18:38 demo.txt</span><br></pre></td></tr></table></figure><p>使用 <code>cat</code> 命令查看文件的内容。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cat demo.txt</span><br><span class="line">Love you.</span><br></pre></td></tr></table></figure><p>你可以使用两个重定向符 (<code>&gt;&gt;</code>) 添加其他的内容到同一个文件中去。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">printf</span> <span class="string">&quot;Love you,too.\n&quot;</span> &gt;&gt; demo.txt</span><br></pre></td></tr></table></figure><p>你可以使用 <code>cat</code> 命令查看这个文件中添加的内容。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ cat demo.txt</span><br><span class="line">Love you.</span><br><span class="line">Love you,too.</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="使用-cat-创建一个文件"><a href="#使用-cat-创建一个文件" class="headerlink" title="使用 cat 创建一个文件"></a>使用 cat 创建一个文件</h3><p><code>cat</code> 表示串联concatenate。在 Linux 经常用于读取一个文件中的数据。</p><p><code>cat</code> 是在类 Unix 系统中最常使用的命令之一。它提供了三个与文本文件相关的功能：显示一个文件的内容、组合多个文件的内容到一个输出以及创建一个新的文件。（LCTT 译注：如果 <code>cat</code> 命令后如果不带任何文件的话，下面的命令在回车后也不会立刻结束，回车后的操作可以按 <code>Ctrl-C</code> 或 <code>Ctrl-D</code> 来结束。）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ cat &gt; demo.txt</span><br><span class="line">Love you.</span><br><span class="line">Love you,too.</span><br><span class="line">^C <span class="comment"># Ctrl + C 结束输入</span></span><br></pre></td></tr></table></figure><p>使用 <code>ls</code> 命令查看创建的文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ls -lh demo.txt</span><br><span class="line">-rw-rw-r--. 1 sogrey sogrey 24 12月 10 21:28 demo.txt</span><br></pre></td></tr></table></figure><p>使用 <code>cat</code> 命令查看文件的内容。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ cat demo.txt</span><br><span class="line">Love you.</span><br><span class="line">Love you,too.</span><br></pre></td></tr></table></figure><p>如果你想向同一个文件中添加其他内容，使用两个连接的重定向符（<code>&gt;&gt;</code>）。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cat &gt;&gt; demo.txt</span><br><span class="line">Love you,everyday.</span><br></pre></td></tr></table></figure><p>你可以使用 <code>cat</code> 命令查看添加的内容。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ cat demo.txt</span><br><span class="line">Love you.</span><br><span class="line">Love you,too.</span><br><span class="line">Love you,everyday.</span><br></pre></td></tr></table></figure><h3 id="使用-vi-vim-命令创建一个文件"><a href="#使用-vi-vim-命令创建一个文件" class="headerlink" title="使用 vi/vim 命令创建一个文件"></a>使用 vi/vim 命令创建一个文件</h3><p><code>vim</code> 是一个向上兼容 <code>vi</code> 的文本编辑器。它通常用来编辑所有种类的纯文本。在编辑程序时特别有用。</p><p><code>vim</code> 中有很多功能可以用于编辑单个文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ vi demo.txt</span><br><span class="line">Love you.</span><br><span class="line">Love you,too.</span><br><span class="line">~</span><br><span class="line">~</span><br><span class="line">~</span><br></pre></td></tr></table></figure><p>按<code>Esc</code>输入<code>:wq</code>保存退出。</p><p>使用 <code>ls</code> 查看刚才创建的文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ls -lh demo.txt</span><br><span class="line">-rw-rw-r--. 1 sogrey sogrey 25 12月 10 21:36 demo.txt</span><br></pre></td></tr></table></figure><p>使用 <code>cat</code> 命令查看文件的内容。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ cat demo.txt</span><br><span class="line">Love you.</span><br><span class="line">Love you,too.</span><br></pre></td></tr></table></figure><h3 id="使用-nano-命令创建一个文件"><a href="#使用-nano-命令创建一个文件" class="headerlink" title="使用 nano 命令创建一个文件"></a>使用 nano 命令创建一个文件</h3><p><code>nano</code> 是一个编辑器，它是一个自由版本的 <code>pico</code> 克隆。<code>nano</code> 是一个小且用户友好的编辑器。它复制了 <code>pico</code> 的外观及优点，并且是一个自由软件，它添加了 <code>pico</code> 缺乏的一系列特性，像是打开多个文件、逐行滚动、撤销/重做、语法高亮、行号等等。</p><p>光标只能使用键盘方向键控制移动，快捷键使用<code>Ctrl</code>+菜单字母标识。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ nano demo.java</span><br><span class="line">public class HelloWorld &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/Sogrey/gitee-cdn/raw/master/imgs/nano创建文件.png" alt="nano创建文件"></p><p>按<code>Ctrl+X</code>离开，<code>Ctrl+Y</code>选择保存，确定文件名回车即可，使用 <code>ls</code> 命令查看创建的文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ls -lh demo.java</span><br><span class="line">-rw-rw-r--. 1 sogrey sogrey 121 12月 10 21:50 demo.java</span><br></pre></td></tr></table></figure><p>使用 <code>cat</code> 命令来查看一个文件的内容。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ cat demo.java</span><br><span class="line">public class HelloWorld &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用-head-命令创建一个文件"><a href="#使用-head-命令创建一个文件" class="headerlink" title="使用 head 命令创建一个文件"></a>使用 head 命令创建一个文件</h3><p><a href="https://www.runoob.com/linux/linux-comm-head.html"><code>head</code></a> 命令通常用于输出一个文件开头的一部分。它默认会打印一个文件的开头 10 行到标准输出。如果有多个文件，则每个文件前都会有一个标题，用来表示文件名。</p><p>如下，创建一个0kb空文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ head -c 0K &gt; demo.txt</span><br></pre></td></tr></table></figure><p>使用 <code>ls</code> 命令查看创建的文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ls -lh demo.txt</span><br><span class="line">-rw-rw-r--. 1 sogrey sogrey 0 12月 10 21:58 demo.txt</span><br></pre></td></tr></table></figure><h3 id="使用-tail-创建一个文件"><a href="#使用-tail-创建一个文件" class="headerlink" title="使用 tail 创建一个文件"></a>使用 tail 创建一个文件</h3><p><code>tail</code> 命令通常用来输出一个文件最后的一部分。它默认会打印每个文件的最后 10 行到标准输出。如果有多个文件，则每个文件前都会有一个标题，用来表示文件名。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ tail -c 0K &gt; demo.txt</span><br></pre></td></tr></table></figure><p>使用 <code>ls</code> 命令查看创建的文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ls -lh demo.txt</span><br><span class="line">-rw-rw-r--. 1 sogrey sogrey 0 12月 10 21:59 demo.txt</span><br></pre></td></tr></table></figure><h3 id="使用-truncate-命令创建一个文件"><a href="#使用-truncate-命令创建一个文件" class="headerlink" title="使用 truncate 命令创建一个文件"></a>使用 truncate 命令创建一个文件</h3><p><code>truncate</code> 命令通常用作将一个文件的尺寸缩小或者扩展为某个指定的尺寸。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ truncate -s 0K demo.txt</span><br></pre></td></tr></table></figure><p>使用 <code>ls</code> 命令检查创建的文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ls -lh demo.txt</span><br><span class="line">-rw-rw-r--. 1 sogrey sogrey 0 12月 10 21:59 demo.txt</span><br></pre></td></tr></table></figure><hr><p>当作笔记，做个记录。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://linux.cn/article-10549-1.html">在 Linux 上创建文件的 10 个方法</a></li><li><a href="https://www.2daygeek.com/create-a-file-in-specific-certain-size-linux/">在Linux上创建一个特定大小的文件</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在 Linux 上，包括设备在内的一切皆文件。Linux用户每天都会多次执行创建文件，但在linux上右键菜单中只有创建文件夹（我们也可以使用&lt;code&gt;mkdir&lt;/code&gt;命令创建），但并没有创建文件的菜单。&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://sogrey.github.io/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://sogrey.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>【Linux】提示用户不在sudoers文件中的解决方法</title>
    <link href="https://sogrey.github.io/article/%E3%80%90Linux%E3%80%91%E6%8F%90%E7%A4%BA%E7%94%A8%E6%88%B7%E4%B8%8D%E5%9C%A8sudoers%E6%96%87%E4%BB%B6%E4%B8%AD%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/"/>
    <id>https://sogrey.github.io/article/【Linux】提示用户不在sudoers文件中的解决方法/</id>
    <published>2020-12-07T02:20:58.000Z</published>
    <updated>2020-12-21T15:42:58.219Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p> 在使用Linux系统过程中，通常情况下，我们都会使用普通用户进行日常操作，而root用户只有在权限分配及系统设置时才会使用，而root用户的密码也不可能公开。普通用户执行到系统程序时，需要临时提升权限，sudo就是我们常用的命令，仅需要输入当前用户密码，便可以完成权限的临时提升。在使用sudo命令的过程中，我们经常会遇到当前用户不在sudoers文件中的提示信息，如果解决该问题呢？通过下面几个步骤，可以很简单的解决此问题。</p><span id="more"></span><p>工具：Oracle VM VirtualBox<br>系统：Ubantu</p><ol><li>切换到root用户权限</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">su root</span><br><span class="line">密码 <span class="comment">#输入密码，密码不可见</span></span><br></pre></td></tr></table></figure><ol><li>查看<code>/etc/sudoers</code>文件权限，通常是只读权限，修改为可写权限</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ls -l /etc/sudoers <span class="comment"># 查看文件权限</span></span><br><span class="line">-r--r-----. 1 root root 4030 9月  25 00:57 /etc/sudoers <span class="comment">#r读 w写 目前是只读状态</span></span><br><span class="line">chmod 777 /etc/sudoers <span class="comment"># 修改为可写权限</span></span><br><span class="line">ls -l /etc/sudoers <span class="comment"># 再次查看文件权限</span></span><br><span class="line">-rwxrwxrwx. 1 root root 4030 9月  25 00:57 /etc/sudoers <span class="comment">#r读 w写 现在是可写状态</span></span><br></pre></td></tr></table></figure><ol><li>执行<code>vi</code>命令，编辑<code>/etc/sudoers</code>文件，添加要提升权限的用户；</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi ./etc/sudoers</span><br></pre></td></tr></table></figure><p>在文件中找到<code>root  ALL=(ALL) ALL</code>，在该行下添加提升权限的用户信息，如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root    ALL&#x3D;(ALL)       ALL</span><br><span class="line">user    ALL&#x3D;(ALL)       ALL</span><br></pre></td></tr></table></figure><br>说明：格式为（<code>用户名    网络中的主机=（执行命令的目标用户）    执行的命令范围</code>）</p><p>保存退出<code>vi</code>,按<code>Esc</code>键输出<code>:wq</code>。</p><pre><code>编辑模式　　使用vi进入文本后，按i开始编辑文本退出编辑模式 　　按ESC键，然后：　　　　退出vi　　　 :q!  不保存文件，强制退出vi命令　　　 :w   保存文件，不退出vi命令　　　 :wq  保存文件，退出vi命令</code></pre><ol><li>保存退出后恢复<code>/etc/sudoers</code>的访问权限为<code>440</code></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">chmod 440 /etc/sudoers <span class="comment"># 恢复只读</span></span><br><span class="line">ls -l /etc/sudoers <span class="comment"># 查看文件读写状态</span></span><br><span class="line">-r--r-----. 1 root root 4030 9月  25 00:57 /etc/sudoers <span class="comment"># r读 w写 目前只读</span></span><br></pre></td></tr></table></figure><p>进行完以上步骤，切换回普通用户，该用户权限提升功能完成。</p><p><img src="https://gitee.com/Sogrey/gitee-cdn/raw/master/imgs/linux提升用户权限sudoers.png" alt="linux提升用户权限sudoers"></p><p><img src="https://gitee.com/Sogrey/gitee-cdn/raw/master/imgs/EulorOS提升用户su权限.png" alt="Huawei EulorOS提升用户su权限"></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://blog.csdn.net/mouday/article/details/88758437">Linux：设置文件和文件夹的读写权限</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt; 在使用Linux系统过程中，通常情况下，我们都会使用普通用户进行日常操作，而root用户只有在权限分配及系统设置时才会使用，而root用户的密码也不可能公开。普通用户执行到系统程序时，需要临时提升权限，sudo就是我们常用的命令，仅需要输入当前用户密码，便可以完成权限的临时提升。在使用sudo命令的过程中，我们经常会遇到当前用户不在sudoers文件中的提示信息，如果解决该问题呢？通过下面几个步骤，可以很简单的解决此问题。&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://sogrey.github.io/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://sogrey.github.io/tags/Linux/"/>
    
      <category term="sudo" scheme="https://sogrey.github.io/tags/sudo/"/>
    
      <category term="sudoers" scheme="https://sogrey.github.io/tags/sudoers/"/>
    
  </entry>
  
  <entry>
    <title>Linux下安装软件</title>
    <link href="https://sogrey.github.io/article/Linux%E4%B8%8B%E5%AE%89%E8%A3%85%E8%BD%AF%E4%BB%B6/"/>
    <id>https://sogrey.github.io/article/Linux下安装软件/</id>
    <published>2020-12-05T05:47:33.000Z</published>
    <updated>2020-12-21T15:42:58.212Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>linux系统下怎么安装软件？</p><ul><li>deb 是 ubuntu 、debian 的格式。</li><li>rpm 是 redhat 、fedora 、suse 的格式。</li></ul><span id="more"></span><h2 id="安装deb文件"><a href="#安装deb文件" class="headerlink" title="安装deb文件"></a>安装deb文件</h2><p>deb是debian发行版的软件包，而ubuntu是基于debian 发行的所以可以用。</p><p>.deb是solaris系统下的安装包后缀名。安装方法如下：</p><ol><li><code>cd</code> 到安装包的目录</li><li><code>dpkg -i 安装包名字</code> 如果权限不够，<code>sudo</code>来凑。</li></ol><p><img src="https://gitee.com/Sogrey/gitee-cdn/raw/master/imgs/安装deb.png" alt=""></p><h2 id="安装rpm文件"><a href="#安装rpm文件" class="headerlink" title="安装rpm文件"></a>安装rpm文件</h2><p>如果你使用的是red hat linux，然后运行以下命令安装：</p><ol><li><code>cd</code> 到安装包的目录</li><li><code>rpm -ivh 安装包名字</code></li></ol><h2 id="安装tar-gz文件"><a href="#安装tar-gz文件" class="headerlink" title="安装tar.gz文件"></a>安装tar.gz文件</h2><p>有时，部分软件是以<code>.tar.gz</code>打包的，比如我要安装的java jdk:jdk-8u161-linux-x64.tar.gz</p><p>执行命令：<code>tar -zxvf jdk-8u161-linux-x64.tar.gz</code></p><p><img src="https://gitee.com/Sogrey/gitee-cdn/raw/master/imgs/安装tar.png" alt=""></p><p>其中必要参数有如下：</p><ul><li><code>-A</code> 新增压缩文件到已存在的压缩</li><li><code>-c</code> 建立新的压缩文件</li><li><code>-d</code> 记录文件的差别</li><li><code>-r</code> 添加文件到已经压缩的文件</li><li><code>-u</code> 添加改变了和现有的文件到已经存在的压缩文件</li><li><code>-x</code> 从压缩的文件中提取文件</li><li><code>-t</code> 显示压缩文件的内容</li><li><code>-z</code> 支持<code>gzip</code>解压文件</li><li><code>-j</code> 支持<code>bzip2</code>解压文件</li><li><code>-Z</code> 支持compress解压文件</li><li><code>-v</code> 显示操作过程</li><li><code>-l</code> 文件系统边界设置</li><li><code>-k</code> 保留原有文件不覆盖</li><li><code>-m</code> 保留文件不被覆盖</li><li><code>-W</code> 确认压缩文件的正确性</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://www.runoob.com/w3cnote/linux-tar-gz.html">Linux tar.gz、tar、bz2、zip 等解压缩、压缩命令详解</a></li><li><a href="https://blog.csdn.net/imyang2007/article/details/7634470">linux tar 解压命令总结</a></li><li><a href="https://www.cnblogs.com/nhdlb/p/11568991.html">Linux：linux下解压*压缩tar.xz、tar、tar.gz、tar.bz2、tar.Z、rar、zip、war等文件方法</a></li><li><a href="https://man.linuxde.net/wget">wget命令</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;linux系统下怎么安装软件？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;deb 是 ubuntu 、debian 的格式。&lt;/li&gt;
&lt;li&gt;rpm 是 redhat 、fedora 、suse 的格式。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://sogrey.github.io/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://sogrey.github.io/tags/Linux/"/>
    
      <category term="deb" scheme="https://sogrey.github.io/tags/deb/"/>
    
      <category term="rpm" scheme="https://sogrey.github.io/tags/rpm/"/>
    
  </entry>
  
  <entry>
    <title>spring-boot项目打包和自启动</title>
    <link href="https://sogrey.github.io/article/spring-boot%E9%A1%B9%E7%9B%AE%E6%89%93%E5%8C%85%E5%92%8C%E8%87%AA%E5%90%AF%E5%8A%A8/"/>
    <id>https://sogrey.github.io/article/spring-boot项目打包和自启动/</id>
    <published>2020-11-30T07:04:27.000Z</published>
    <updated>2020-12-21T15:42:58.217Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>springboot的打包方式有很多种。有打成war的，有打成jar的，也有直接提交到github，通过jekins进行打包部署的。这里主要介绍如何打成jar进行部署。不推荐用war，因为springboot适合前后端分离，打成jar进行部署更合适。</p><span id="more"></span><h2 id="spring-boot项目打包"><a href="#spring-boot项目打包" class="headerlink" title="spring-boot项目打包"></a>spring-boot项目打包</h2><ol><li><p>在application.properties当中配置端口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">server.port&#x3D;8080</span><br></pre></td></tr></table></figure></li><li><p>pom.xml添加配置，已经配置过可忽略</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--配置主类入口--&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">mainClass</span>&gt;</span>top.Sogrey.MainApplication<span class="tag">&lt;/<span class="name">mainClass</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>项目右键-&gt;<code>Run As</code>-&gt;<code>Maven clean</code> 先清理</p></li><li><p>项目右键-&gt;<code>Run As</code>-&gt;<code>Maven install</code> Maven执行打包</p><p><img src="https://gitee.com/Sogrey/gitee-cdn/raw/master/imgs/spring-boot-项目打包.png" alt="spring-boot-项目打包"></p><p>等待出现<code>BUILD SUCCESS</code>字样，打包成功，在项目根目录<code>target</code>下查看生成的<code>jar</code>文件。</p></li></ol><h2 id="运行jar包"><a href="#运行jar包" class="headerlink" title="运行jar包"></a>运行jar包</h2><p>执行命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar myProject.jar</span><br></pre></td></tr></table></figure><h2 id="添加到系统自启动"><a href="#添加到系统自启动" class="headerlink" title="添加到系统自启动"></a>添加到系统自启动</h2><h3 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h3><p>准备工具：<a href="https://github.com/winsw/winsw/releases">winsw</a>,是一个可以将任何应用程序注册成服务的软件</p><ol><li>将下载的<code>WinSW.NET4.exe</code>与springboot项目打包的jar包（比如:<code>myProject.jar</code>）放在同一个文件夹中，并将<code>WinSW.NET4.exe</code>重命名为与jar文件同名,比如：<code>myProject.exe</code>。</li><li><p>同目录下创建同名的xml文件,比如，输入内容：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--安装成Windows服务后的服务名--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span>&gt;</span>myProjectServiceID<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--显示的服务名称--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>myProjectServiceName<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--对服务的描述--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span>此处可填写该服务的描述<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--这里写java的路径，如何配置了环境变量直接写&quot;java&quot;就行--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">executable</span>&gt;</span>java<span class="tag">&lt;/<span class="name">executable</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--Xmx256m 代表堆内存最大值为256MB -jar后面的是项目名--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">arguments</span>&gt;</span>-Xmx256m -jar myProject.jar<span class="tag">&lt;/<span class="name">arguments</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--日志模式--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">logmode</span>&gt;</span>rotate<span class="tag">&lt;/<span class="name">logmode</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>cmd到当前目录下，执行安装命令</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myProject.exe install</span><br></pre></td></tr></table></figure></li><li><p>命令提示符界面输入启动服务命令</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">net</span> <span class="built_in">start</span> myProjectServiceName</span><br></pre></td></tr></table></figure></li><li><p>打开系统服务功能：运行——输入<code>services.msc</code>，即可看见自己命名的服务<code>myProjectServiceName</code>,自启动就好了，可重启系统再次查看系统服务功能。</p></li><li><p>删除服务。既然启动了服务，我们也可以删除他，同样是两步：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">net</span> stop myProjectServiceName #停止运行服务</span><br><span class="line">myProject.exe uninstall #删除服务</span><br></pre></td></tr></table></figure></li><li><p>一键部署命令：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#例如myProjectStart.bat内容如下：</span><br><span class="line">myProject.exe install</span><br><span class="line"><span class="built_in">net</span> <span class="built_in">start</span> myProjectServiceName</span><br><span class="line"></span><br><span class="line">#例如myProjectStop.bat内容如下：</span><br><span class="line"><span class="built_in">net</span> stop myProjectServiceName</span><br><span class="line">myProject.exe uninstall</span><br></pre></td></tr></table></figure><h3 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h3></li><li><p>开启后台自执行</p></li></ol><p>命令： <code>nohup</code> 详细文档说明可参考<a href="https://www.runoob.com/linux/linux-comm-nohup.html">Linux nohup 命令</a></p><p>语法格式:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup Command [ Arg … ] [　&amp; ]</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup java -jar myProject.jar &amp;</span><br></pre></td></tr></table></figure><p>在终端如果看到以下输出说明运行成功：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">appending output to nohup.out</span><br></pre></td></tr></table></figure></p><ol><li>停止运行,杀死进程</li></ol><p>先使用以下命令查找到 nohup 运行脚本到 PID，然后使用 kill 命令来删除</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -aux | grep <span class="string">&quot;myProject.jar&quot;</span></span><br></pre></td></tr></table></figure><p>参数说明：</p><ul><li><code>a</code> : 显示所有程序</li><li><code>u</code> : 以用户为主的格式来显示</li><li><code>x</code> : 显示所有程序，不区分终端机</li></ul><p>另外也可以使用 <code>ps -def | grep &quot;myProject.jar&quot;</code> 命令来查找。</p><p>找到 PID 后，就可以使用 <a href="https://www.runoob.com/linux/linux-comm-kill.html">kill</a> PID 来删除。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">kill</span> -9  进程号PID</span><br></pre></td></tr></table></figure></p><p>以下命令在后台执行 root 目录下的 runoob.sh 脚本，并重定向输入到 runoob.log 文件：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup /root/runoob.sh &gt; runoob.log 2&gt;&amp;1 &amp;</span><br></pre></td></tr></table></figure><br><code>2&gt;&amp;1</code> 解释：</p><p>将标准错误 2 重定向到标准输出 &amp;1 ，标准输出 &amp;1 再被重定向输入到 runoob.log 文件中。</p><ul><li><code>0</code> – stdin (standard input，标准输入)</li><li><code>1</code> – stdout (standard output，标准输出)</li><li><code>2</code> – stderr (standard error，标准错误输出)</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;springboot的打包方式有很多种。有打成war的，有打成jar的，也有直接提交到github，通过jekins进行打包部署的。这里主要介绍如何打成jar进行部署。不推荐用war，因为springboot适合前后端分离，打成jar进行部署更合适。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="https://sogrey.github.io/categories/Java/"/>
    
    
      <category term="Java" scheme="https://sogrey.github.io/tags/Java/"/>
    
      <category term="Spring boot" scheme="https://sogrey.github.io/tags/Spring-boot/"/>
    
      <category term="Maven" scheme="https://sogrey.github.io/tags/Maven/"/>
    
      <category term="Myeclipse" scheme="https://sogrey.github.io/tags/Myeclipse/"/>
    
      <category term="winsw" scheme="https://sogrey.github.io/tags/winsw/"/>
    
  </entry>
  
  <entry>
    <title>使用Maven搭建spring boot项目（下）</title>
    <link href="https://sogrey.github.io/article/%E4%BD%BF%E7%94%A8Maven%E6%90%AD%E5%BB%BAspring-boot%E9%A1%B9%E7%9B%AE%EF%BC%88%E4%B8%8B%EF%BC%89/"/>
    <id>https://sogrey.github.io/article/使用Maven搭建spring-boot项目（下）/</id>
    <published>2020-11-29T04:06:01.000Z</published>
    <updated>2020-12-21T15:42:58.221Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><a href="/article/使用Maven搭建spring-boot项目/">上节</a>我们搭建了一个简单的Spring boot web项目，要想运行起来还需加入Spring boot，现在安排。</p><span id="more"></span><h2 id="在pom-xml中引入相关依赖"><a href="#在pom-xml中引入相关依赖" class="headerlink" title="在pom.xml中引入相关依赖"></a>在pom.xml中引入相关依赖</h2><ol><li><p>引入<code>spring-boot-start-parent</code>，spring官方的叫stater poms，它可以提供dependency management，也就是依赖管理，引入以后在声明其它dependency的时候就不需要version了。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span>  </span><br><span class="line">     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  </span><br><span class="line">     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  </span><br><span class="line">     <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.5.3.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>引入<code>spring-boot-starter-web</code>，spring官方解释spring-boot-start-web包含了spring webmvc和tomcat等web开发的特性。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span>  </span><br><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>  </span><br><span class="line">          <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  </span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  </span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span> </span><br></pre></td></tr></table></figure></li><li><p>引入<code>spring-boot-maven-plugin</code>,用于启动spring，否则是无法启动的。如果使用maven的<code>spring-boot:run</code>的话就不需要此配置。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span>  </span><br><span class="line">      <span class="tag">&lt;<span class="name">plugins</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span>  </span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  </span><br><span class="line">               <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin <span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  </span><br><span class="line">          <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span>  </span><br><span class="line">       <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><p>完整pom.xml见<a href="https://github.com/Sogrey/SpringBootDemo/blob/main/pom.xml">https://github.com/Sogrey/SpringBootDemo/blob/main/pom.xml</a></p><h2 id="添加java相关代码"><a href="#添加java相关代码" class="headerlink" title="添加java相关代码"></a>添加java相关代码</h2><ol><li><p>创建启动类，然后在启动类声明让spring boot自动给我们配置spring需要的配置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> top.sogrey;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Controller;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.ResponseBody;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span> <span class="comment">// Spring Boot项目的核心注解，主要目的是开启自动配置</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloApplication</span> </span>&#123;   </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在main方法中启动一个应用，即：这个应用的入口</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(HelloApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中：</p><p>其中<code>@SpringBootApplication</code>声明让spring boot自动给程序进行必要的配置，等价于以默认属性使用<code>@Configuration</code>，<code>@EnableAutoConfiguration</code>和<code>@ComponentScan</code>。</p></li><li><p>添加控制器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> top.sogrey.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Controller;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.ResponseBody;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Controller</span> <span class="comment">// 标明这是一个SpringMVC的Controller控制器</span></span><br><span class="line"><span class="meta">@RequestMapping(value = &quot;/api&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/&quot;)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/hello&quot;)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello &quot;</span>+name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><p>两种运行方式：</p><ol><li><p>右键<code>Run As</code> -&gt; <code>Java Application</code>。之后打开浏览器输入地址：</p><p><a href="http://localhost:10111/api/">http://localhost:10111/api/</a></p><p><a href="http://localhost:10111/api/hello?name=Sogrey">http://localhost:10111/api/hello?name=Sogrey</a>  //带参数</p><p>试试看。</p></li><li><p>第二种方式右键<code>Run as</code> –&gt;<code>Maven build</code> – 在Goals里输入<code>spring-boot:run</code> ,然后Apply,最后点击Run。</p></li></ol><p>github地址：<a href="https://github.com/Sogrey/SpringBootDemo.git">https://github.com/Sogrey/SpringBootDemo.git</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;/article/使用Maven搭建spring-boot项目/&quot;&gt;上节&lt;/a&gt;我们搭建了一个简单的Spring boot web项目，要想运行起来还需加入Spring boot，现在安排。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="https://sogrey.github.io/categories/Java/"/>
    
    
      <category term="Java" scheme="https://sogrey.github.io/tags/Java/"/>
    
      <category term="Spring boot" scheme="https://sogrey.github.io/tags/Spring-boot/"/>
    
      <category term="Maven" scheme="https://sogrey.github.io/tags/Maven/"/>
    
      <category term="Myeclipse" scheme="https://sogrey.github.io/tags/Myeclipse/"/>
    
  </entry>
  
  <entry>
    <title>使用Maven搭建spring boot项目</title>
    <link href="https://sogrey.github.io/article/%E4%BD%BF%E7%94%A8Maven%E6%90%AD%E5%BB%BAspring-boot%E9%A1%B9%E7%9B%AE/"/>
    <id>https://sogrey.github.io/article/使用Maven搭建spring-boot项目/</id>
    <published>2020-11-28T02:06:01.000Z</published>
    <updated>2020-12-21T15:42:58.221Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>准备工具：</p><ul><li>MyEclipse CI 2019.4.0</li><li>JDK1.8</li><li>Tomcat 8.5</li></ul><p>MyEclipse 和 JDK 的下载安装就不细说了，自行百度，一带而过。</p><span id="more"></span><h2 id="MyEclipse使用Maven搭建spring-boot项目"><a href="#MyEclipse使用Maven搭建spring-boot项目" class="headerlink" title="MyEclipse使用Maven搭建spring boot项目"></a>MyEclipse使用Maven搭建spring boot项目</h2><ol><li><p><code>File</code>-&gt;<code>New</code>-&gt;<code>Project</code>-&gt;<code>Maven Project</code></p><p><img src="https://gitee.com/Sogrey/gitee-cdn/raw/master/imgs/create-spring-boot-by-ME1.png" alt="create-spring-boot-by-ME"></p></li><li><p><code>Next</code>, 选择<code>Use default Workspace location</code>。</p><p><img src="https://gitee.com/Sogrey/gitee-cdn/raw/master/imgs/create-spring-boot-by-ME2.png" alt="create-spring-boot-by-ME"></p></li><li><p><code>Next</code>, 选择<code>maven-archetype-webapp</code>创建一个webapp目录结构的项目</p><p><img src="https://gitee.com/Sogrey/gitee-cdn/raw/master/imgs/create-spring-boot-by-ME3.png" alt="create-spring-boot-by-ME"></p></li><li><p>填<code>Group Id</code>，<code>Artifact Id</code>，和<code>Package，点击</code>Finish`</p><ul><li>GroupId：一般是公司名或组织名。</li><li>ArtifactId：一般是project名。</li><li>Packaging：打包类型，jar/war/rar/ear/pom等，默认是jar。</li><li>Version：版本号，GroupId+ArtifactId+Packaging+Version构成项目的唯一标识。</li></ul><p><img src="https://gitee.com/Sogrey/gitee-cdn/raw/master/imgs/create-spring-boot-by-ME4.png" alt="create-spring-boot-by-ME"></p></li><li><p>等待MyEclipse创建项目,完成后，文件目录结构如下</p><p><img src="https://gitee.com/Sogrey/gitee-cdn/raw/master/imgs/create-spring-boot-by-ME5.png" alt="create-spring-boot-by-ME"></p></li></ol><h2 id="Eclipse暂时通过Spring-Initializr官网快速构建spring-boot工程"><a href="#Eclipse暂时通过Spring-Initializr官网快速构建spring-boot工程" class="headerlink" title="Eclipse暂时通过Spring Initializr官网快速构建spring boot工程"></a>Eclipse暂时通过Spring Initializr官网快速构建spring boot工程</h2><ol><li>使用浏览器打开： <a href="http://start.spring.io">http://start.spring.io</a></li><li>填写项目相关信息，选取依赖，然后生成项目</li><li>解压项目，在Eclipse导入Maven工程</li></ol><p><img src="https://gitee.com/Sogrey/gitee-cdn/raw/master/imgs/create-spring-boot-by-Spring-Initializr.png" alt="create-spring-boot-by-Spring-Initializr"></p><p>到此，一个简单的Spring boot web项目就初步搭建了，要想运行起来还需加入Spring boot，<a href="/article/使用Maven搭建spring-boot项目（下）/">下节</a>安排。</p><h2 id="解决一些异常"><a href="#解决一些异常" class="headerlink" title="解决一些异常"></a>解决一些异常</h2><ol><li><p>创建完成后，发现index.jsp报错，打开index.jsp，报错如下</p><p><img src="https://gitee.com/Sogrey/gitee-cdn/raw/master/imgs/create-spring-boot-by-ME6.png" alt="create-spring-boot-by-ME"></p><p>在项目上右键-&gt;<code>build path</code>-&gt;<code>AddLibrary</code>,选择MyEclipse Server Library,Next后，选择一个Tomcat，Finish。</p><p><img src="https://gitee.com/Sogrey/gitee-cdn/raw/master/imgs/create-spring-boot-by-ME8.png" alt="create-spring-boot-by-ME"></p></li><li><p>pom.xml报错,有小红叉</p><p>项目上右键选<code>maven</code>-&gt;<code>Update Project</code></p><p><img src="https://gitee.com/Sogrey/gitee-cdn/raw/master/imgs/create-spring-boot-by-ME9.png" alt="create-spring-boot-by-ME"></p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;准备工具：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;MyEclipse CI 2019.4.0&lt;/li&gt;
&lt;li&gt;JDK1.8&lt;/li&gt;
&lt;li&gt;Tomcat 8.5&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;MyEclipse 和 JDK 的下载安装就不细说了，自行百度，一带而过。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="https://sogrey.github.io/categories/Java/"/>
    
    
      <category term="Java" scheme="https://sogrey.github.io/tags/Java/"/>
    
      <category term="Spring boot" scheme="https://sogrey.github.io/tags/Spring-boot/"/>
    
      <category term="Maven" scheme="https://sogrey.github.io/tags/Maven/"/>
    
      <category term="Myeclipse" scheme="https://sogrey.github.io/tags/Myeclipse/"/>
    
  </entry>
  
  <entry>
    <title>解锁github高级搜索技能</title>
    <link href="https://sogrey.github.io/article/%E8%A7%A3%E9%94%81github%E9%AB%98%E7%BA%A7%E6%90%9C%E7%B4%A2%E6%8A%80%E8%83%BD/"/>
    <id>https://sogrey.github.io/article/解锁github高级搜索技能/</id>
    <published>2020-11-17T15:10:38.000Z</published>
    <updated>2020-12-21T15:42:58.227Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>作为程序员，github是必备网站，那么我们一般是怎么在github中中查找开源项目呢？今天我也来学习下常用的github高级搜索命令。</p><span id="more"></span><h2 id="搜索仓库"><a href="#搜索仓库" class="headerlink" title="搜索仓库"></a>搜索仓库</h2><h3 id="按仓库名称、说明或自述文件内容搜索"><a href="#按仓库名称、说明或自述文件内容搜索" class="headerlink" title="按仓库名称、说明或自述文件内容搜索"></a>按仓库名称、说明或自述文件内容搜索</h3><p>通过 <code>in</code> 限定符，您可以将搜索限制为仓库名称<code>name</code>、仓库说明<code>description</code>、自述文件内容<code>readme</code>或这些的任意组合。如果省略此限定符，则只搜索仓库名称和说明。</p><table><thead><tr><th style="text-align:left">限定符</th><th style="text-align:left">示例</th></tr></thead><tbody><tr><td style="text-align:left"><code>in:name</code></td><td style="text-align:left"><strong>sogrey in:name</strong> 匹配其名称中含有 “sogrey” 的仓库。</td></tr><tr><td style="text-align:left"><code>in:description</code></td><td style="text-align:left"><strong>sogrey in:name,description</strong> 匹配其名称或说明中含有 “sogrey” 的仓库。</td></tr><tr><td style="text-align:left"><code>in:readme</code></td><td style="text-align:left"><strong>sogrey in:readme</strong> 匹配其自述文件中提及 “sogrey” 的仓库。</td></tr></tbody></table><p>也可以直接搜索指定仓库：</p><table><thead><tr><th>限定符</th><th>示例</th></tr></thead><tbody><tr><td><code>repo:owner/name</code></td><td><strong>repo:sogrey/sogrey</strong> 匹配特定仓库名称。</td></tr></tbody></table><h3 id="在用户或组织的仓库内搜索"><a href="#在用户或组织的仓库内搜索" class="headerlink" title="在用户或组织的仓库内搜索"></a>在用户或组织的仓库内搜索</h3><p>要在特定用户或组织拥有的所有仓库中搜索，您可以使用 <code>user</code> 或 <code>org</code> 限定符。</p><table><thead><tr><th style="text-align:left">限定符</th><th style="text-align:left">示例</th></tr></thead><tbody><tr><td style="text-align:left"><code>user:*USERNAME*</code></td><td style="text-align:left"><strong>user:defunkt forks:&gt;100</strong> 匹配来自 @defunkt、拥有超过 100 复刻的仓库。</td></tr><tr><td style="text-align:left"><code>org:*ORGNAME*</code></td><td style="text-align:left"><strong>org:github</strong> 匹配来自 GitHub 的仓库。</td></tr></tbody></table><h3 id="按仓库大小搜索"><a href="#按仓库大小搜索" class="headerlink" title="按仓库大小搜索"></a>按仓库大小搜索</h3><p><code>size</code> 限定符使用大于、小于和范围限定符查找匹配特定大小（以千字节  <code>kb</code> 为单位）的仓库。</p><table><thead><tr><th style="text-align:left">限定符</th><th style="text-align:left">示例</th></tr></thead><tbody><tr><td style="text-align:left"><code>size:*n*</code></td><td style="text-align:left"><strong>size:1000</strong> 匹配恰好为 1 MB 的仓库。</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><strong>size:&gt;=30000</strong> 匹配至少为 30 MB 的仓库。</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><strong>size:&lt;50</strong> 匹配小于 50 KB 的仓库。</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><strong>size:50..120</strong> 匹配介于 50 KB 与 120 KB 之间的仓库。</td></tr></tbody></table><h3 id="按关注者数量搜索"><a href="#按关注者数量搜索" class="headerlink" title="按关注者数量搜索"></a>按关注者数量搜索</h3><p>使用 <code>followers</code> 限定符以及大于、小于和范围限定符基于仓库拥有的关注者数量过滤仓库。</p><table><thead><tr><th style="text-align:left">限定符</th><th style="text-align:left">示例</th></tr></thead><tbody><tr><td style="text-align:left"><code>followers:*n*</code></td><td style="text-align:left"><strong>node followers:&gt;=10000</strong> 匹配有 10,000 或更多关注者提及文字 “node” 的仓库。</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><strong>styleguide linter followers:1..10</strong> 匹配拥有 1 到 10 个关注者并且提及 “styleguide linter” 一词的的仓库。</td></tr></tbody></table><h3 id="按fork数量搜索"><a href="#按fork数量搜索" class="headerlink" title="按fork数量搜索"></a>按fork数量搜索</h3><p><code>forks</code> 限定符使用大于、小于和范围限定符指定仓库应具有的复刻数量。</p><table><thead><tr><th style="text-align:left">限定符</th><th style="text-align:left">示例</th></tr></thead><tbody><tr><td style="text-align:left"><code>forks:*n*</code></td><td style="text-align:left"><strong>forks:5</strong> 匹配只有 5 个复刻的仓库。</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><strong>forks:&gt;=205</strong> 匹配具有至少 205 个复刻的仓库。</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><strong>forks:&lt;90</strong> 匹配具有少于 90 个复刻的仓库。</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><strong>forks:10..20</strong> 匹配具有 10 到 20 个复刻的仓库。</td></tr></tbody></table><h3 id="按star数量搜索"><a href="#按star数量搜索" class="headerlink" title="按star数量搜索"></a>按star数量搜索</h3><p>使用大于、小于和范围限定符基于仓库具有的星标数量搜索仓库</p><table><thead><tr><th style="text-align:left">限定符</th><th style="text-align:left">示例</th></tr></thead><tbody><tr><td style="text-align:left"><code>stars:*n*</code></td><td style="text-align:left"><strong>stars:500</strong> 匹配恰好具有 500 个星号的仓库。</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><strong>stars:10..20</strong> 匹配具有 10 到 20 个星号、小于 1000 KB 的仓库。</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><strong>stars:&gt;=500 fork:true language:php</strong> 匹配具有至少 500 个星号，包括复刻的星号（以 PHP 编写）的仓库。</td></tr></tbody></table><h3 id="按仓库创建或上次更新时间搜索"><a href="#按仓库创建或上次更新时间搜索" class="headerlink" title="按仓库创建或上次更新时间搜索"></a>按仓库创建或上次更新时间搜索</h3><p>您可以基于创建时间或上次更新时间过滤仓库。对于仓库创建，您可以使用 <code>created</code> 限定符；要了解仓库上次更新的时间，您要使用 <code>pushed</code> 限定符。<code>pushed</code> 限定符将返回仓库列表，按仓库中任意分支上最近进行的提交排序。</p><p>两者均采用日期作为参数。日期格式必须遵循 ISO8601标准，即 <code>YYYY-MM-DD</code>（年-月-日）。您也可以在日期后添加可选的时间信息 <code>THH:MM:SS+00:00</code>，以便按小时、分钟和秒进行搜索。这是 <code>T</code>，随后是 <code>HH:MM:SS</code>（时-分-秒）和 UTC 偏移 (<code>+00:00</code>)。</p><p>日期支持大于、小于和范围限定符。</p><table><thead><tr><th style="text-align:left">限定符</th><th style="text-align:left">示例</th></tr></thead><tbody><tr><td style="text-align:left"><code>created:*YYYY-MM-DD*</code></td><td style="text-align:left"><strong>webos created:&lt;2011-01-01</strong> 匹配具有 “webos” 字样、在 2011 年之前创建的仓库。</td></tr><tr><td style="text-align:left"><code>pushed:*YYYY-MM-DD*</code></td><td style="text-align:left"><strong>css pushed:&gt;2013-02-01</strong> 匹配具有 “css” 字样、在 2013 年 1 月之后收到推送的仓库。</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><strong>case pushed:&gt;=2013-03-06 fork:only</strong> 匹配具有 “case” 字样、在 2013 年 3 月 6 日或之后收到推送并且作为复刻的仓库。</td></tr></tbody></table><h3 id="按语言搜索"><a href="#按语言搜索" class="headerlink" title="按语言搜索"></a>按语言搜索</h3><p>基于其编写采用的主要语言搜索仓库。</p><table><thead><tr><th style="text-align:left">限定符</th><th style="text-align:left">示例</th></tr></thead><tbody><tr><td style="text-align:left"><code>language:*LANGUAGE*</code></td><td style="text-align:left"><strong>rails language:javascript</strong> 匹配具有 “rails” 字样、以 JavaScript 编写的仓库。</td></tr></tbody></table><h3 id="按topic搜索"><a href="#按topic搜索" class="headerlink" title="按topic搜索"></a>按topic搜索</h3><p>查找归类为特定主题的所有仓库。</p><table><thead><tr><th style="text-align:left">限定符</th><th style="text-align:left">示例</th></tr></thead><tbody><tr><td style="text-align:left"><code>topic:*TOPIC*</code></td><td style="text-align:left"><strong>topic:jekyll</strong>匹配已归类为 “jekyll” 主题的仓库。</td></tr></tbody></table><h3 id="按topic数量搜索"><a href="#按topic数量搜索" class="headerlink" title="按topic数量搜索"></a>按topic数量搜索</h3><p>使用 <code>topics</code> 限定符以及大于、小于和范围限定符按应用于仓库的主题数量搜索仓库。</p><table><thead><tr><th style="text-align:left">限定符</th><th style="text-align:left">示例</th></tr></thead><tbody><tr><td style="text-align:left"><code>topics:*n*</code></td><td style="text-align:left"><strong>topics:5</strong> 匹配具有五个主题的仓库。</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><strong>topics:&gt;3</strong> 匹配超过三个主题的仓库。</td></tr></tbody></table><h3 id="按许可搜索"><a href="#按许可搜索" class="headerlink" title="按许可搜索"></a>按许可搜索</h3><p>按其许可搜索仓库。您必须使用许可关键词按特定许可或许可系列过滤仓库。</p><table><thead><tr><th style="text-align:left">限定符</th><th style="text-align:left">示例</th></tr></thead><tbody><tr><td style="text-align:left"><code>license:*LICENSE_KEYWORD*</code></td><td style="text-align:left"><strong>license:apache-2.0</strong> 匹配根据 Apache License 2.0 授权的仓库。</td></tr></tbody></table><h3 id="按公共或私有仓库搜索"><a href="#按公共或私有仓库搜索" class="headerlink" title="按公共或私有仓库搜索"></a>按公共或私有仓库搜索</h3><p>基于仓库是公共还是私有来过滤搜索。</p><table><thead><tr><th style="text-align:left">限定符</th><th style="text-align:left">示例</th></tr></thead><tbody><tr><td style="text-align:left"><code>is:public</code></td><td style="text-align:left"><strong>is:public org:github</strong> 匹配 GitHub 拥有的公共仓库。</td></tr><tr><td style="text-align:left"><code>is:private</code></td><td style="text-align:left"><strong>is:private pages</strong> 匹配您有访问权限且包含 “pages” 字样的私有仓库。</td></tr></tbody></table><h2 id="搜索代码"><a href="#搜索代码" class="headerlink" title="搜索代码"></a>搜索代码</h2><h3 id="按文件内容或文件路径搜索"><a href="#按文件内容或文件路径搜索" class="headerlink" title="按文件内容或文件路径搜索"></a>按文件内容或文件路径搜索</h3><p>使用 <code>in</code> 限定符，您可以将搜索限制为源代码文件的内容、文件路径或两者。如果省略此限定符，则只搜索文件内容。</p><table><thead><tr><th style="text-align:left">限定符</th><th style="text-align:left">示例</th></tr></thead><tbody><tr><td style="text-align:left"><code>in:file</code></td><td style="text-align:left"><strong>octocat in:file</strong> 匹配文件内容中出现 “octocat” 的代码。</td></tr><tr><td style="text-align:left"><code>in:path</code></td><td style="text-align:left"><strong>octocat in:path</strong> 匹配文件路径中出现 “octocat” 的代码。</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><strong>octocat in:file,path</strong> 匹配文件内容或文件路径中出现 “octocat” 的代码。</td></tr></tbody></table><h3 id="在用户或组织的仓库内搜索-1"><a href="#在用户或组织的仓库内搜索-1" class="headerlink" title="在用户或组织的仓库内搜索"></a>在用户或组织的仓库内搜索</h3><p>要在特定用户或组织拥有的所有仓库中搜索代码，您可以使用 <code>user</code> 或 <code>org</code> 限定符。要在特定仓库中搜索代码，您可以使用 <code>repo</code> 限定符。</p><table><thead><tr><th style="text-align:left">限定符</th><th style="text-align:left">示例</th></tr></thead><tbody><tr><td style="text-align:left"><code>user:*USERNAME*</code></td><td style="text-align:left"><strong>user:defunkt extension:rb</strong> 匹配来自 @defunkt、以 <em>.rb</em> 结尾的代码。</td></tr><tr><td style="text-align:left"><code>org:*ORGNAME*</code></td><td style="text-align:left"><strong>org:github extension:js</strong> 匹配来自 GitHub、以 <em>.js</em> 结尾的代码。</td></tr><tr><td style="text-align:left"><code>repo:*USERNAME/REPOSITORY*</code></td><td style="text-align:left"><strong>repo:mozilla/shumway extension:as</strong> 匹配来自 @mozilla 的 shumway 项目、以 <em>.as</em> 结尾的代码。</td></tr></tbody></table><h3 id="按文件位置搜索"><a href="#按文件位置搜索" class="headerlink" title="按文件位置搜索"></a>按文件位置搜索</h3><p>可使用 <code>path</code> 限定符搜索仓库中特定位置显示的源代码。使用 <code>path:/</code> 可搜索位于仓库根目录级别的文件。或者，指定目录名称或目录路径以搜索位于该命令或其任何子目录中的文件。</p><table><thead><tr><th style="text-align:left">限定符</th><th style="text-align:left">示例</th></tr></thead><tbody><tr><td style="text-align:left"><code>path:/</code></td><td style="text-align:left"><strong>octocat filename:readme path:/</strong> 匹配位于仓库根目录级别且含有 “octocat” 字样的 <em>readme</em> 文件。</td></tr><tr><td style="text-align:left"><code>path:*DIRECTORY*</code></td><td style="text-align:left"><strong>form path:cgi-bin language:perl</strong> 匹配位于 <em>cgi-bin</em> 目录或其任何子目录中且含有 “form” 字样的 Perl 文件。</td></tr><tr><td style="text-align:left"><code>path:*PATH/TO/DIRECTORY*</code></td><td style="text-align:left"><strong>console path:app/public language:javascript</strong> 匹配 <em>app/public</em> 目录或其任何子目录（即使其位于 <em>app/public/js/form-validators</em> 中）中且含有 “console” 字样的 JavaScript 文件。</td></tr></tbody></table><h3 id="按语言搜索-1"><a href="#按语言搜索-1" class="headerlink" title="按语言搜索"></a>按语言搜索</h3><p>可以基于所编写的语言搜索代码。</p><table><thead><tr><th style="text-align:left">限定符</th><th style="text-align:left">示例</th></tr></thead><tbody><tr><td style="text-align:left"><code>language:*LANGUAGE*</code></td><td style="text-align:left"><strong>element language:xml size:100</strong> 匹配标记为 XML 且恰好有 100 个字节的并含有 “element” 字样的代码。</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><strong>display language:scss</strong> 匹配标记为 SCSS 且含有 “display” 字样的代码。</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><strong>org:mozilla language:markdown</strong> 匹配标记为 Markdown 且来自所有 @mozilla 仓库的代码。</td></tr></tbody></table><h3 id="按文件大小搜索"><a href="#按文件大小搜索" class="headerlink" title="按文件大小搜索"></a>按文件大小搜索</h3><p>可以使用 <code>size</code> 限定符基于代码所在文件的大小搜索源代码。<code>size</code> 限定符使用大于、小于和范围限定符基于在其中找到代码的文件的字节大小来过滤结果。</p><table><thead><tr><th style="text-align:left">限定符</th><th style="text-align:left">示例</th></tr></thead><tbody><tr><td style="text-align:left"><code>size:*n*</code></td><td style="text-align:left"><strong>function size:&gt;10000 language:python</strong> 匹配含有 “function” 字样、以 Python 编写、位于大于 10 KB 的文件中的代码。</td></tr></tbody></table><h3 id="按文件名搜索"><a href="#按文件名搜索" class="headerlink" title="按文件名搜索"></a>按文件名搜索</h3><p><code>filename</code> 限定符匹配具有特定文件名的代码文件。您还可以使用文件查找器在仓库中查找文件。更多信息请参阅“在 GitHub 上查找文件”。</p><table><thead><tr><th style="text-align:left">限定符</th><th style="text-align:left">示例</th></tr></thead><tbody><tr><td style="text-align:left"><code>filename:*FILENAME*</code></td><td style="text-align:left"><strong>filename:linguist</strong> 匹配名为 “linguist” 的文件。</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><strong>filename:.vimrc commands</strong> 匹配含有 “commands” 字样的 <em>.vimrc</em> 文件。</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><strong>filename:test_helper path:test language:ruby</strong> 匹配 <em>test</em> 目录内名为 <em>test_helper</em> 的 Ruby 文件。</td></tr></tbody></table><h3 id="按文件扩展名搜索"><a href="#按文件扩展名搜索" class="headerlink" title="按文件扩展名搜索"></a>按文件扩展名搜索</h3><p><code>extension</code> 限定符匹配具有特定文件扩展名的代码文件。</p><table><thead><tr><th style="text-align:left">限定符</th><th style="text-align:left">示例</th></tr></thead><tbody><tr><td style="text-align:left"><code>extension:*EXTENSION*</code></td><td style="text-align:left"><strong>form path:cgi-bin extension:pm</strong> 匹配含有 “form” 字样、位于 <em>cgi-bin</em> 下且具有 <em>.pm</em> 文件扩展名的代码。</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><strong>icon size:&gt;200000 extension:css</strong> 匹配大于 200 KB、以 .css 结尾且含有 “icon” 字样的文件。</td></tr></tbody></table><h2 id="github官方高级搜索页面"><a href="#github官方高级搜索页面" class="headerlink" title="github官方高级搜索页面"></a>github官方高级搜索页面</h2><p>github官方地址：<a href="https://github.com/search/advanced">https://github.com/search/advanced</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;作为程序员，github是必备网站，那么我们一般是怎么在github中中查找开源项目呢？今天我也来学习下常用的github高级搜索命令。&lt;/p&gt;
    
    </summary>
    
      <category term="github" scheme="https://sogrey.github.io/categories/github/"/>
    
    
      <category term="github" scheme="https://sogrey.github.io/tags/github/"/>
    
  </entry>
  
  <entry>
    <title>如何完全卸载AutoCAD</title>
    <link href="https://sogrey.github.io/article/%E5%A6%82%E4%BD%95%E5%AE%8C%E5%85%A8%E5%8D%B8%E8%BD%BDAutoCAD/"/>
    <id>https://sogrey.github.io/article/如何完全卸载AutoCAD/</id>
    <published>2020-07-25T23:26:18.000Z</published>
    <updated>2020-12-21T15:42:58.224Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>最近开发CAD图纸相关，卸载重装AutoCAD时遇装不上了，提示是已安装。这是因为上一次卸载后没有清理干净。</p><span id="more"></span><h2 id="如何完全卸载AutoCAD"><a href="#如何完全卸载AutoCAD" class="headerlink" title="如何完全卸载AutoCAD"></a>如何完全卸载AutoCAD</h2><p>先说明我的操作系统是 <code>window 10 专业版</code>，安装的CAD版本是 <code>AutoCAD 2020简体中文版</code>。</p><p>具体操作如下：</p><p>1、在电脑左下角，<code>开始（Windows）</code> &gt; <code>设置</code> &gt; <code>应用</code> &gt; <code>应用和功能</code> 最下面找到<code>程序和功能</code> 点击打开 <code>卸载或更改程序</code> ，在控制面板中，找到<strong>Autodesk</strong>，一个一个的只要是能卸载的，都卸载掉。</p><p><img src="https://gitee.com/Sogrey/gitee-cdn/raw/master/imgs/TIM-20200726081959.png" alt="如何完全卸载cad"></p><p>2、打开桌面我的电脑，找到AUTOCAD安装的文件夹，删掉。一般是在C盘，或自己装的其它盘。都看看，找到删掉。</p><p>还有一个隐藏位置，在<code>C://ProgramData</code>下，都删了，这里包含你安装的CAD所有版本。</p><p><img src="https://gitee.com/Sogrey/gitee-cdn/raw/master/imgs/TIM-20200726082227.png" alt="如何完全卸载cad"></p><p>3、彻底删除CAD注册表</p><p>在电脑左下角，点开始，运行，输入<code>regedit</code>回车或点确定。</p><p><img src="https://gitee.com/Sogrey/gitee-cdn/raw/master/imgs/TIM-20200726082331.png" alt="如何完全卸载cad"></p><p>出现注册表，找到“HKEY_CURRENT_USER\software\”目录下的Autodesk文件夹，在Autodesk文件夹上右键，删除。</p><p><img src="https://gitee.com/Sogrey/gitee-cdn/raw/master/imgs/TIM-20200726082552.png" alt="如何完全卸载（删除）cad吗？"></p><p>找到“HKEY_LOCAL_MACHINE\software\”目录下的Autodesk文件夹，在Autodesk文件夹上右键，删掉。</p><p><img src="https://gitee.com/Sogrey/gitee-cdn/raw/master/imgs/TIM-20200726082659.png" alt="如何完全卸载（删除）cad吗？"></p><p>删除“HKEY_LOCAL_MACHINE\software\classes\installer\products”目录下的挨个找一遍，一般会出现开头和尾号一样的几条在一起，看右边是否有<code>AutoCAD</code>字样，有就删掉。</p><p>注：这里不同版本的CAD，products下的可能不一样，大家点开耐心看图二右侧处是不是CAD，是的话删除。</p><p><img src="https://gitee.com/Sogrey/gitee-cdn/raw/master/imgs/TIM-20200726082817.png" alt="如何完全卸载CAD"></p><p>再关闭注册表，现在再重装就能装上了。</p><h2 id="安装异常"><a href="#安装异常" class="headerlink" title="安装异常"></a>安装异常</h2><h3 id="安装CAD时，提示1603错误"><a href="#安装CAD时，提示1603错误" class="headerlink" title="安装CAD时，提示1603错误"></a>安装CAD时，提示1603错误</h3><p><img src="https://gitee.com/Sogrey/gitee-cdn/raw/master/imgs/autocad-error-1603.png" alt="安装CAD时，提示1603错误"></p><ol><li><p>删除安装程序，找到一下路径<code>C:\Program Files (x86)\Common Files\Autodesk Shared\AdskLicensing</code>，然后以管理员身份运行duUNINSTALL.EXE程序，删除软件,重试。</p></li><li><p>如果还存在以上问题，以管理员身份运行命令窗口，然后输入命令<code>C:\Program Files(x86)\Common Files\Autodesk Shared\AdskLicensing\Current\AdskLicensingService\AdskLicensingService.exe</code> 重新安装软件，再试，建议下载最新的安装包</p></li></ol><h3 id="Cad-界面出现乱码"><a href="#Cad-界面出现乱码" class="headerlink" title="Cad 界面出现乱码"></a>Cad 界面出现乱码</h3><p>如图：</p><p><img src="https://gitee.com/Sogrey/gitee-cdn/raw/master/imgs/CAD界面乱码.png" alt="CAD界面乱码"></p><p>解决方案：</p><p>找到AutoCAD安装目录跟目下的Fonts文件夹，该文件夹存放的就是字体了，在该文件夹下找到simsun.ttc字体删除就好了。</p><p><img src="https://gitee.com/Sogrey/gitee-cdn/raw/master/imgs/CAD界面乱码修复.png" alt="CAD界面乱码修复"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近开发CAD图纸相关，卸载重装AutoCAD时遇装不上了，提示是已安装。这是因为上一次卸载后没有清理干净。&lt;/p&gt;
    
    </summary>
    
      <category term="软件" scheme="https://sogrey.github.io/categories/%E8%BD%AF%E4%BB%B6/"/>
    
    
      <category term="软件" scheme="https://sogrey.github.io/tags/%E8%BD%AF%E4%BB%B6/"/>
    
      <category term="AutoCAD" scheme="https://sogrey.github.io/tags/AutoCAD/"/>
    
  </entry>
  
  <entry>
    <title>专为编程而生的字体 —— Fira Code</title>
    <link href="https://sogrey.github.io/article/%E4%B8%93%E4%B8%BA%E7%BC%96%E7%A8%8B%E8%80%8C%E7%94%9F%E7%9A%84%E5%AD%97%E4%BD%93/"/>
    <id>https://sogrey.github.io/article/专为编程而生的字体/</id>
    <published>2020-07-25T01:53:02.000Z</published>
    <updated>2020-12-21T15:42:58.220Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>程序员使用很多符号，通常用几个字符编码。对于人类大脑，像 <code>-&gt;</code> ，<code>&lt;=</code> 或 <code>:=</code> 这样的序列是单个逻辑标记，即使它们在屏幕上占用两个或三个字符。 您的眼睛花费非零的能量来扫描、解析和连接多个字符到一个逻辑字符中。理想情况下，所有编程语言都应该为运算符设计完整的 Unicode 符号，但目前还不是这样。</p><span id="more"></span><h2 id="迄今为止最漂亮的适合程序员的字体"><a href="#迄今为止最漂亮的适合程序员的字体" class="headerlink" title="迄今为止最漂亮的适合程序员的字体"></a>迄今为止最漂亮的适合程序员的字体</h2><p>这是一款<strong>美到没朋友</strong>的等宽字体 —— Fira Code，<a href="https://github.com/tonsky/FiraCode">github地址在此</a>,可以从这里下载最新版。<a href="https://github.com/tonsky/FiraCode/tree/master/distr">这里</a>多种格式可供选择。</p><p>如题所述，在我们写代码的时候，经常会用到 <code>-&gt;</code>、<code>=&gt;</code>、<code>::</code>、<code>&gt;=</code>、<code>.=</code> 等超过一个字符的操作符，但是这个操作符其实在现实生活中，很多都有与之对应的数学符号，只是因为不能通过常规的方式输入而选择用多个字符代表一个操作符。而 Fira Code 包含一组用于常见编程多字符组合的连字，它通过渲染，将我们输入的多个字符变为更有意义的数学符号，<strong>这有助于更快地阅读和理解代码。</strong>不仅如此，Fira Code 还更正了一些常见操作符，比如 <code>...</code>、<code>\\</code> 等的字符间距。</p><p>但请注意：</p><ol><li>Fira Code 只是将你输入的字符渲染呈现成连字，只是样子发生变化，功能没有发生任何改变。</li><li>Fira Code 的连字可能会给一些不用 Fira Code 字体的人带来困扰，因为原来的语法里没有这些符号。</li></ol><p>先上段代码感受下：</p><p><img src="https://gitee.com/Sogrey/gitee-cdn/raw/master/imgs/TIM截图20200725102225.png" alt="Fira Code预览"></p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>以 VSCode 为例。</p><ol><li>打开 vscode 的配置页面，按住 <code>CTRL + SHIFT + P</code>，然后输入 <code>set</code>，选择<code>首选项：打开设置（json）</code>；</li><li><p>将下列代码复制到 setting.json 中。</p> <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;editor.fontFamily&quot;: &quot;&#x27;Fira Code&#x27;, Consolas, &#x27;Courier New&#x27;, monospace&quot;,//将 &#x27;Fira Code&#x27; 放在最前面</span><br></pre></td></tr></table></figure><p> 如果想某个类型文件中生效需添加：</p> <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&quot;editor.fontFamily&quot;: &quot;Fira Code&quot;,//设置的字体类型为 Fira Code</span><br><span class="line">&quot;editor.fontLigatures&quot;: true,//这个控制是否启用字体连字，true启用，false不启用，这里选择启用</span><br><span class="line">&quot;editor.fontSize&quot;: 14,//设置字体大小</span><br><span class="line">&quot;editor.fontWeight&quot;: &quot;normal&quot;,//这个设置字体粗细，可选normal,bold,&quot;100&quot;~&quot;900&quot;等，选择合适的就行</span><br></pre></td></tr></table></figure></li><li><p>然后保存，字体就应用成功了。</p></li></ol><h2 id="浏览器支持"><a href="#浏览器支持" class="headerlink" title="浏览器支持"></a>浏览器支持</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- HTML --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;https://cdn.jsdelivr.net/gh/tonsky/FiraCode@1.206/distr/fira_code.css&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* CSS */</span></span><br><span class="line"><span class="keyword">@import</span> url(<span class="attribute">https</span>://cdn.jsdelivr.net/gh/tonsky/FiraCode@<span class="number">1.206</span>/distr/fira_code.css);</span><br><span class="line"><span class="comment">/* Specify in CSS */</span></span><br><span class="line"><span class="attribute">font-family</span>: <span class="string">&#x27;Fira Code&#x27;</span>, monospace;</span><br></pre></td></tr></table></figure><ul><li>IE 10+，Edge：使用 font-feature-settings启用：“calt”1;</li><li>火狐</li><li>Safari浏览器</li><li>基于 Chromium 的浏览器（Chrome，Opera）</li><li>ACE</li><li>CodeMirror（使用 font-variant-ligatures: contextual; 启用）</li><li>JetBrains Mono介绍和下载：<a href="https://www.jetbrains.com/lp/mono(免费开源">https://www.jetbrains.com/lp/mono(免费开源</a>)</li></ul><h2 id="其他带有连字的等宽字体"><a href="#其他带有连字的等宽字体" class="headerlink" title="其他带有连字的等宽字体"></a>其他带有连字的等宽字体</h2><ul><li><a href="https://github.com/i-tu/Hasklig">Hasklig </a>（免费）</li><li><a href="http://www.fsd.it/fonts/pragmatapro.htm">PragmataPro </a>（€59）</li><li><a href="http://larsenwork.com/monoid/">Monoid </a>（免费）</li><li><a href="https://github.com/kika/fixedsys">Fixedsys Excelsior </a>（免费）</li><li><a href="https://be5invis.github.io/Iosevka/">Iosevka </a>（免费）</li><li><a href="https://github.com/SSNikolaevich/DejaVuSansCode">DejaVu Sans Code </a>（免费）</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h2&gt;&lt;p&gt;程序员使用很多符号，通常用几个字符编码。对于人类大脑，像 &lt;code&gt;-&amp;gt;&lt;/code&gt; ，&lt;code&gt;&amp;lt;=&lt;/code&gt; 或 &lt;code&gt;:=&lt;/code&gt; 这样的序列是单个逻辑标记，即使它们在屏幕上占用两个或三个字符。 您的眼睛花费非零的能量来扫描、解析和连接多个字符到一个逻辑字符中。理想情况下，所有编程语言都应该为运算符设计完整的 Unicode 符号，但目前还不是这样。&lt;/p&gt;
    
    </summary>
    
      <category term="字体" scheme="https://sogrey.github.io/categories/%E5%AD%97%E4%BD%93/"/>
    
    
      <category term="字体" scheme="https://sogrey.github.io/tags/%E5%AD%97%E4%BD%93/"/>
    
  </entry>
  
  <entry>
    <title>Js之Promise</title>
    <link href="https://sogrey.github.io/article/Js%E4%B9%8BPromise/"/>
    <id>https://sogrey.github.io/article/Js之Promise/</id>
    <published>2020-04-28T02:14:21.000Z</published>
    <updated>2020-12-21T15:42:58.212Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="promise是什么？"><a href="#promise是什么？" class="headerlink" title="promise是什么？"></a>promise是什么？</h2><ul><li>promise是一个对象，对象和函数的区别就是对象可以保存状态，有3个状态分别是：等待态（默认） 成功态 失败态，函数不可以（闭包除外）</li><li>并未剥夺函数return的能力，因此无需层层传递callback，进行回调获取数据</li><li>代码风格，容易理解，便于维护</li><li>多个异步等待合并便于解决</li></ul><p>ES6 原生提供了 Promise 对象。</p><span id="more"></span><h2 id="promise-之前如何异步操作"><a href="#promise-之前如何异步操作" class="headerlink" title="promise 之前如何异步操作"></a>promise 之前如何异步操作</h2><h3 id="1-事件监听"><a href="#1-事件监听" class="headerlink" title="1. 事件监听"></a>1. 事件监听</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">&#x27;#start&#x27;</span>).addEventListener(<span class="string">&#x27;click&#x27;</span>, start, <span class="literal">false</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">start</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 响应事件，进行相应的操作</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// jquery on 监听</span></span><br><span class="line">$(<span class="string">&#x27;#start&#x27;</span>).on(<span class="string">&#x27;click&#x27;</span>, start)</span><br></pre></td></tr></table></figure><h3 id="2-回调"><a href="#2-回调" class="headerlink" title="2. 回调"></a>2. 回调</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 比较常见的有ajax</span></span><br><span class="line">$.ajax(<span class="string">&#x27;http://www.wysite.com/&#x27;</span>, &#123;</span><br><span class="line"> success (res) &#123;</span><br><span class="line">   <span class="comment">// 这里可以监听res返回的数据做回调逻辑的处理</span></span><br><span class="line"> &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者在页面加载完毕后回调</span></span><br><span class="line">$(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="comment">// 页面结构加载完成，做回调逻辑处理</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong>异步回调的问题</strong>：</p><ul><li>之前处理异步是通过纯粹的回调函数的形式进行处理</li><li>很容易进入到回调地狱中，剥夺了函数return的能力</li><li>问题可以解决，但是难以读懂，维护困难</li><li>稍有不慎就会踏入回调地狱 - 嵌套层次深，不好维护</li></ul><h2 id="promise-如何异步操作"><a href="#promise-如何异步操作" class="headerlink" title="promise 如何异步操作"></a>promise 如何异步操作</h2><blockquote><p>使用回调函数存在的问题在于他剥夺了我们使用 <code>return</code> 和 <code>throw</code> 这些关键字的能力。而 Promise 很好地解决了这一切。</p></blockquote><p>每个promise实例都有一个<code>.then</code>方法。<code>resolve</code>（成功）,<code>reject</code>（失败）。<br><code>resolve</code>,<code>reject</code>是自己定义的，你需要他成功或者失败，要先调用的是谁？一旦成功了就不能失败；如果你手动抛出一个异常那就注定会进失败的结果了；</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span>  promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>) =&gt;</span> &#123;</span><br><span class="line">   <span class="comment">//耗时异步操作</span></span><br><span class="line">   resolve(<span class="string">&#x27;成功&#x27;</span>); reject(<span class="string">&#x27;失败&#x27;</span>);</span><br><span class="line">&#125;).then(<span class="function"><span class="params">data</span> =&gt;</span>&#123;    <span class="comment">//成功</span></span><br><span class="line">    <span class="built_in">console</span>.log(data)</span><br><span class="line">&#125;,<span class="function"><span class="params">err</span> =&gt;</span>&#123;   <span class="comment">//失败</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;err&#x27;</span>,err)</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//成功</span></span><br></pre></td></tr></table></figure><p>其中：</p><ol><li><p>resolve作用是，将Promise对象的状态从“未完成”变为“成功”（即从 pending 变为 resolved），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去；reject作用是，将Promise对象的状态从“未完成”变为“失败”（即从 pending 变为 rejected），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。</p></li><li><p>promise有三个状态：<br>   1、pending[待定]初始状态<br>   2、fulfilled[实现]操作成功<br>   3、rejected[被否决]操作失败<br>   当promise状态发生改变，就会触发then()里的响应函数处理后续步骤；<br>   promise状态一经改变，不会再变。</p></li><li><p>Promise对象的状态改变，只有两种可能：<br>   从pending变为fulfilled<br>   从pending变为rejected。<br>   这两种情况只要发生，状态就凝固了，不会再变了。如果改变已经发生了，你再对Promise对象添加回调函数，也会立即得到这个结果。这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。</p></li></ol><h2 id="promise-api"><a href="#promise-api" class="headerlink" title="promise api"></a>promise api</h2><ul><li><p>romise.resolve()</p></li><li><p>Promise.reject()</p></li><li><p>Promise.prototype.then()</p></li><li><p>Promise.prototype.catch()</p></li><li><p>Promise.all() // 所有的完成</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="built_in">Promise</span>.all([p1,p2,p3]);</span><br></pre></td></tr></table></figure><ul><li>Promise.race() // 竞速，完成一个即可</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise"><strong>Promise</strong> - JavaScript | MDN</a></li><li><a href="https://www.jianshu.com/p/063f7e490e9a">Javascript 中的神器——Promise</a></li><li><a href="https://www.liaoxuefeng.com/wiki/1022910821149312/1023024413276544">Promise @廖雪峰</a></li><li><a href="https://www.jianshu.com/p/1b63a13c2701">promise @王云飞_小四_wyunfei</a></li><li><a href="https://blog.csdn.net/qq_34645412/article/details/81170576">ES6 Promise用法小结</a></li><li><a href="https://zhuanlan.zhihu.com/p/146895201">从0到1掌握Promise</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;promise是什么？&quot;&gt;&lt;a href=&quot;#promise是什么？&quot; class=&quot;headerlink&quot; title=&quot;promise是什么？&quot;&gt;&lt;/a&gt;promise是什么？&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;promise是一个对象，对象和函数的区别就是对象可以保存状态，有3个状态分别是：等待态（默认） 成功态 失败态，函数不可以（闭包除外）&lt;/li&gt;
&lt;li&gt;并未剥夺函数return的能力，因此无需层层传递callback，进行回调获取数据&lt;/li&gt;
&lt;li&gt;代码风格，容易理解，便于维护&lt;/li&gt;
&lt;li&gt;多个异步等待合并便于解决&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;ES6 原生提供了 Promise 对象。&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="https://sogrey.github.io/categories/JavaScript/"/>
    
    
      <category term="JS" scheme="https://sogrey.github.io/tags/JS/"/>
    
      <category term="JavaScript" scheme="https://sogrey.github.io/tags/JavaScript/"/>
    
      <category term="Promise" scheme="https://sogrey.github.io/tags/Promise/"/>
    
  </entry>
  
  <entry>
    <title>总结2019，展望2020</title>
    <link href="https://sogrey.github.io/article/zj2019-zw2020/"/>
    <id>https://sogrey.github.io/article/zj2019-zw2020/</id>
    <published>2019-12-16T14:49:45.000Z</published>
    <updated>2020-12-21T15:42:58.218Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>2019年也接近尾声了，一直想写个总结，留坑已久，要么因为工作，要么因为个人还未想好要怎么写，直到现在，2020已来。</p><h3 id="回顾2018"><a href="#回顾2018" class="headerlink" title="回顾2018"></a>回顾2018</h3><p>先看一眼<a href="/article/再见2018，你好2019/">2018年总结</a>。</p><p>2018年终期望实现情况：</p><ul><li>2018年接触到了很多新的开发语言，像<code>Kotlin</code>、<code>Flutter</code>、<code>Electron</code>等，19年除了使用<code>Kotlin</code>开发过项目写过App，使用<code>Electron</code>写过一个简单的音乐播放器（跟着教程写的）外，<code>Flutter</code>、<code>Vue</code>、<code>TypeScript</code>等基本都没有进展，<code>Kotlin</code>仍有像<code>高阶函数</code>、<code>协程</code>这样的硬骨头要啃。</li><li>2018年阅读技术软文的习惯，2019仍在延续，但相比18年，阅读量有所减少，现在更喜欢将所读到、动手实践（编程）得到知识，心得体会记录下来。</li></ul><h3 id="总结2019"><a href="#总结2019" class="headerlink" title="总结2019"></a>总结2019</h3><h4 id="工作上"><a href="#工作上" class="headerlink" title="工作上"></a>工作上</h4><p>总的来说，2019年，基本已经没有参与App的开发，主要的工作精力放在了Three.js引擎的开发和跟进维护，参与的项目有<em>DC设计器引擎</em>以及其衍生项目<em>HW数字化3D引擎</em>。接触Three.js快一年了，比起刚刚接触Three.js时一脸懵逼，现在已经好很多，很多的问题和需求已经可以独立开发。</p><p>年尾两个月开始转向Cesium 3D引擎的开发，此时又有了刚开始Three.js开发时的无力感。除了在之前Three.js引擎中积累的3D知识经验外，其他又踏上了从零学习之路，Cesium中很多新的知识都要自习。</p><p>2019年养成新的习惯，虽说开始也是被动的，但最终想来也是好的，那就是每周总结周报。我记录周报的习惯一般是现将之前未完成的罗列记录，新接到的需求也先纳入记录，待完成后标记完成。这样的好处就是可以帮助我们记录我们工作方向，那些急需完成，那些未完成，规划好时间，本周做不完的需要延续到次周，这样我们的目标便更加明确了。</p><h4 id="个人技能提升"><a href="#个人技能提升" class="headerlink" title="个人技能提升"></a>个人技能提升</h4><p>至于个人技能方面，2019，想了想，好像也没学习什么新的知识或涉及新的领域。说有提升，也是有的，2019虽说没参与公司App开发，但自己有需求或者巩固下Android知识不至于遗忘，还是会建一些demo级的App，主要是面向一些知识点或某个框架，今年新建的App全部采用了Kotlin开发，顺便提升下kotlin开发技能和运用。18年时接触过Flutter开发App，但今年却运用很少，在这方面提升甚微，希望2020年有所突破。</p><p>19年还有个比较大的提升就是培养自己多写文档，不止用于公司产品（引擎API文档），自己学习和积累都采用文档的形式记录下来。俗话说，好记性不如烂笔头。18年时，文档采用gitbook发布为电子书的形式，今年，改用vuepress(基于Node.js)发布线上文档，访问加载速度比gitbook更好。</p><p>知识在于积累，除了记录学习笔记外，我还建了两个面经库（<a href="https://sogrey.top/Android_QA/">Android 面经库</a>、 <a href="https://sogrey.top/Web-QA/">前端面经库</a>），旨在记录平时阅读时、工作中遇到的问题及解决方案。</p><p>年末双12购入自己朝思暮想第一个域名（<a href="sogrey.top">sogrey.top</a>）（真心图便宜），用于绑定我的github pages。</p><h4 id="存在不足"><a href="#存在不足" class="headerlink" title="存在不足"></a>存在不足</h4><ul><li>虽然接触Three.js快一年了，实现公司引擎业务也不想起初那样技穷。但直到现在也没有彻底把Three.js系统化的理一遍，一直都是有了需求采取研究寻找解决方案，处于被动。期间只简单整理了些（<a href="https://sogrey.top/Three.js-start/">Three.js-start</a>）。</li><li>切入Cesium，虽然仍是需求驱动，但是这次并不像学习Three.js一样，只学习和了解了需求中遇到的方面，闲余时间查阅了很多系列教程、博客、视频，列出一个很简陋的学习路线和框架（<a href="https://sogrey.top/Cesium-start/">Cesium 入门</a>），自己根据这样的一个路线学习。现在仍有两三个大的核心的还没有做深入学习，处于空白。即使学习了解过得知识也不一定理解的很透彻。</li><li>2019年总起说起来有些懒散了，除了最后两个月学习Cesium时认认真真的查阅资料学习整理外，其他记录笔记很少，Three.js也有记录但更新频率很低，毕竟有的知识慢慢熟悉起来也觉得懒得记录了，后面遇到问题明明记得看到过却想不起来，想查阅却没有东西可查。</li></ul><h3 id="展望2020"><a href="#展望2020" class="headerlink" title="展望2020"></a>展望2020</h3><h4 id="工作方面"><a href="#工作方面" class="headerlink" title="工作方面"></a>工作方面</h4><p>参与Cesium引擎开发，仍需很多东西要学，总是觉得没有方向，刚确定一个比较粗略的路线想系统的学习一下。由于是团队开发，而我们各自开发某个模块，我先采用插件式开发，开发时可脱离主API，开发完成或成型时在引入调用。学无止境，我把学习中遇到的好的资源、教程、博客、开源项目、资源收录在一起，共享学习资料。希望新的一年，站在这些巨人肩上能有更高的拔升。</p><p>Three.js引擎，仍有新的需求，比如同一个页面展示多个canvas用来展示多个场景，并且每个不相互干扰，这是个新的方向，可能会对之前引擎大改。</p><p>至于对于公司的工作建议或其他建议：</p><ul><li>需求明确化。需求是产品的前提，在做产品时第一步就是要明确需求，这样的产品才不会脱离方向。做App最不想听到的是<code>照5D BIM平台功能做个5D BIM App出来。</code>可以做，要做成什么样，使用什么样的主题，哪些功能能在App上比较实用，而哪些并不实用，实现以什么样的方式实现，有没有相关的设计样例图例，这些都是需求。</li><li>周报制度继续沿用。为了有效推进公司各项管理工作，进一步发挥管理部门职能作用，加强信息沟通与交流，便于公司领导了解主要工作进展情况。这些说起来很大，往小了说，便于自己明确自己的工作重心及工作内容，发现自己的不足，防止跑偏。每周我们都有自己的开发内容，也有不定期不定时新来的需求，先把它们一一列队，编好轻重缓急标识，再去一一攻克解决他们。</li><li>适当一些培训。不论是技术还是产品，适当的一些培训也好让员工了解自己公司的产品，以及提出好的意见，商务向客户推荐我们产品更有底气，开发对于产品有了更深的了解，开发起来也更顺手。不用再一个人埋头琢磨（经常性打扰别人自己也觉得不好意思了）。</li></ul><h4 id="个人方面"><a href="#个人方面" class="headerlink" title="个人方面"></a>个人方面</h4><ul><li>考取驾照。</li></ul><p>至于新知识的学习和巩固提升：</p><ul><li>移动开发kotlin、flutter、以及组件化、MVP等都是提升目标，列在计划。</li><li>引擎开发，Three.js和Cesium，尤其是Cesium要学习的很多 。</li><li>继续维护<a href="https://sogrey.top/Android_QA/">Android 面经库</a>和<a href="https://sogrey.top/Web-QA/">前端面经库</a>，并完善<a href="https://sogrey.top/Cesium-start/">Cesium 入门</a>，完善Cesium知识提升应用能力。</li><li>入手ECMAScript 6、webpack（Anguler、vue）、TypeScript</li></ul><p>总结现在，着眼未来！做更好的自己，成为公司期望的优秀成员！2020年，希望一切都好，继续努力。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="年终总结" scheme="https://sogrey.github.io/categories/%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="年终总结" scheme="https://sogrey.github.io/tags/%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
</feed>
